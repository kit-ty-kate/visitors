\documentclass[11pt,a4paper,twoside]{article}
\usepackage[left=25mm,right=25mm,top=25mm,bottom=25mm,marginparwidth=50pt]{geometry}
\setlength\abovecaptionskip{0pt} % Reduce space above figure captions.
\usepackage{lmodern} % This gives us a bold monospace font.
\renewcommand{\rmdefault}{ptm} % Times.
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[bookmarks=true,bookmarksopen=true,colorlinks=true,%
            linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\usepackage{marginnote}
\usepackage{listings}
\input{listings-ocaml}
\lstset{language=ocaml}
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage{xspace}
\input{macros}
% Style.
\renewcommand{\emph}[1]{\textbf{#1}}
\input{version}

% ------------------------------------------------------------------------------
% Headings.

\title{Visitors\\\normalsize version \visitorsversion}
\date{}
\begin{document}
\author{François Pottier\\ Inria Paris\\ \email{francois.pottier@inria.fr}}
\maketitle

% ------------------------------------------------------------------------------

\clearpage
\tableofcontents
\clearpage

% ------------------------------------------------------------------------------

\begin{flushright}
  Les visites font toujours plaisir, si ce n'est en arrivant, du moins en
  partant. \\ --- \textit{Jean de La Bruyère}
\end{flushright}

\vspace{1cm}

% ------------------------------------------------------------------------------
% ------------------------------------------------------------------------------

\section{Introduction}
\label{sec:intro}

% ------------------------------------------------------------------------------

\subsection{What is a visitor?}

A visitor for a data structure is a class whose methods implement a traversal
of this data structure. By default, the visitor methods do not have
interesting behavior: they just cause control to go down into the data
structure and come back up, without performing any actual computation.
Nevertheless, by defining subclasses where one method or a few methods are
overridden, nontrivial behavior can be obtained. Therefore, visitors allow
many operations on this data structure to be defined with little effort.

Visitors come in several varieties. An \iter visitor traverses a data
structure and returns no result. It can nevertheless have side effects,
including updating a piece of mutable state, raising an exception, and
performing input/output. A \map visitor traverses a data structure and returns
another data structure: typically, a copy of its argument that has been
transformed in some way. A \reduce visitor traverses a data structure and
returns a value that somehow summarizes it: computing the size of a data
structure is a typical example. Finally, as it is sometimes necessary to
simultaneously traverse two data structures of identical shape, there are
visitors of arity two: we refer to them as \itertwo, \maptwo, and \reducetwo
visitors.

% ------------------------------------------------------------------------------

\subsection{What does this package offer?}

Visitors have extremely regular structure. As a result, whereas implementing
them by hand is boring and error-prone, generating them automatically is often
possible. The \visitors package extends the syntax of OCaml%
%
\footnote{Technically, \visitors is a plugin for \ppxderiving, which itself is
  a preprocessor extension for the OCaml compiler.}
%
so as to make it easy for the programmer to request the automatic generation
of visitor classes. Visitor classes for many forms of user-defined data types
can be generated and, if necessary, combined (via multiple inheritance) with
hand-written visitor classes, making the framework quite powerful.

% ------------------------------------------------------------------------------
% ------------------------------------------------------------------------------

\section{Walkthrough}

% ------------------------------------------------------------------------------

\subsection{Setup}
\label{sec:intro:setup}

In order to install the \visitors package, an \opam user should issue the
following commands:
\begin{verbatim}
  opam update
  opam install visitors
\end{verbatim}
To use the package, an \ocamlbuild user should add the
following line in her project's \texttt{\_tags} file:
\begin{lstlisting}
  true: package(visitors.ppx), package(visitors.runtime)
\end{lstlisting}
Finally, a user of \merlin should add the following lines in her project's
\texttt{.merlin} file:
\begin{lstlisting}
  PKG visitors.ppx
  PKG visitors.runtime
\end{lstlisting}

% ------------------------------------------------------------------------------

% TEMPORARY marquer int[@opaque] dans tous les exemples, pour éviter
% l'appel à visit_int; expliquer

\begin{figure}[t]
% In an OCaml source file, a type definition can be annotated with
% \oc|[@@deriving visitors { ... }]|:
\orig{expr00}
% This causes the following code to be (invisibly) generated:
\vspace{-\baselineskip}
\processed{expr00}
\caption{A visitor of the \iter variety}
\label{fig:expr00}
\end{figure}

\subsection{Defining an \iter visitor}
\label{sec:intro:iter:def}

Suppose we need to manipulate arithmetic expressions built out of integer
literals and binary additions. The abstract syntax of these expressions can be
described by an algebraic data type \oc|expr|, shown in the first part of
\fref{fig:expr00}.
%
By annotating this type definition with \oc|[@@deriving visitors { ... }]|, we
request the automated generation of a visitor for expressions. The annotation
\oc|[@@deriving visitors| \oc|{ ... }]| must carry at least one parameter,
\variety, which indicates what variety of visitor is desired.

The code of the visitor class, which is automatically generated and in normal
use remains invisible, is shown in the second part of \fref{fig:expr00}. The
name of this class is by default the value of the \variety parameter. It can
be changed, if desired, by explicitly supplying a \name parameter.

A visitor takes the form of an OCaml class, whose methods are named after the
types and data constructors that appear in the type definition. In
\fref{fig:expr00}, for instance, the method \tyconvisitor{expr} is named after
the type \oc|expr|, while the methods \dataconvisitor{EConst} and
\dataconvisitor{EAdd} are named after the data constructors \oc|EConst| and
\oc|EAdd|.

Different varieties of visitors differ in the computation that is performed
``on the way up'', after the recursive calls have finished, therefore differ
in the return types of the visitor methods. \iter is the simplest variety. An
\iter visitor performs no computation on the way up, so its methods have
return type \oc|unit|.

In an \iter visitor, the generated visitor methods do nothing. In
\fref{fig:expr00}, for instance, the method \tyconvisitor{expr} inspects its
argument \oc|this| and recursively invokes either \dataconvisitor{EConst} or
\dataconvisitor{EAdd}, as appropriate. The method \dataconvisitor{EConst} does
nothing.\footnote{More precisely, it calls the method \tyconvisitor{int},
  which is inherited from \oc|VisitorsRuntime.iter| and does nothing.}
% TEMPORARY supprimer cette note si la méthode visit_int disparaît
% TEMPORARY noter qu'on peut marquer (int[@opaque]) pour éviter cet appel
The method \dataconvisitor{EAdd} performs two recursive calls to
\tyconvisitor{expr}, which does nothing, so \dataconvisitor{EAdd} itself does
nothing.

Every method is parameterized with an environment \oc|env|, which is carried
down into every recursive call and is otherwise unused. The type of this
environment is undetermined: it is up to the (user-defined) subclasses of the
visitor class to decide what the type of \oc|env| should be and (possibly)
where and how this environment should be enriched.

% One could note that the visitor class is parameterized over 'self,
% but it is perhaps a bit early for such a remark.

The fields of a data constructor or record are traversed left to right, in the
order they are declared. In a list-like data structure, the field that holds a
pointer to the list tail should be declared last, so as to ensure that the
traversal requires constant stack space.

% ------------------------------------------------------------------------------

\begin{figure}[t]
\codefollowup{expr00}
\origfirstline{expr04}{3}
\caption{Counting the number of addition nodes in an expression}
\label{fig:expr04}
\end{figure}

\subsection{Using an \iter visitor}
\label{sec:intro:iter:usage}

Naturally, traversing a data structure without actually computing anything is
not a very sensible thing to do. Things become interesting when at least one
visitor method is overridden so as to give rise to nontrivial behavior.
Suppose, for instance, that we wish to count the number of addition nodes in
an expression. This can be done as shown in \fref{fig:expr04}. We create an
object~\oc|v| that is both a counter (that is, an object equipped with a
mutable field~\oc|count|) and a visitor, and we override its method
\dataconvisitor{EAdd} so that the counter is incremented every time this
method is invoked. There remains to run the visitor, by invoking its
\tyconvisitor{expr} method, and to return the final value of the counter. The
environment, in this example, is unused; we let it have type \unit.

This may seem a rather complicated way of counting the addition nodes in an
expression. Of course, one could give a direct recursive definition of the
function \oc|count|, in a few lines of code, without using a visitor at all.
The point of employing a visitor, as done in Figures~\ref{fig:expr00}
and~\ref{fig:expr04}, is that no changes to the code are required when the
type of expressions is extended with new cases.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr01}
\vspace{-\baselineskip}
\processed{expr01}
\caption{A visitor of the \map variety}
\label{fig:expr01}
\end{figure}

\subsection{\map visitors}
\label{sec:intro:map}

An \iter visitor returns no result. Although, as illustrated previously
(\sref{sec:intro:iter:usage}), it can use private mutable state to accumulate
information, there are applications for which such a visitor is not suitable.
One class of such applications is tree transformations. To transform an
expression into an expression, one should use a visitor of another variety,
namely \map.

A \map visitor is shown in \fref{fig:expr01}. In comparison with the \iter
visitor of \fref{fig:expr00}, the generated code is identical, except that,
instead of returning the unit value \oc|()|, the method
\dataconvisitor{EConst} reconstructs an \oc|EConst| expression, while the
method \dataconvisitor{EAdd} reconstructs an \oc|EAdd| expression.

A \map visitor behaves (by default) as an identity function: it constructs a
copy of the data structure that it visits. If the data structure is immutable,
this is rather pointless: in order to obtain nontrivial behavior, at least one
method should be overridden. In the data structure is mutable, though, even
the default behavior is potentially of interest: it constructs a deep copy of
its argument.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr00endo}
\vspace{-\baselineskip}
\processed{expr00endo}
\caption{A visitor of the \mapendo variety}
\label{fig:expr00endo}
\end{figure}

\subsection{\mapendo visitors}
\label{sec:intro:endo}

\mapendo visitors are a slight variation of \map visitors. Whereas a \map
visitor systematically allocates a copy of the memory block that it receives
as an argument, an \mapendo visitor (\fref{fig:expr00endo}) first tests if the
newly allocated block would have exactly the same contents as the original
block, and if so, re-uses the original block instead.
% TEMPORARY I have heard this idea attributed to Gérard Huet.

This trick allows saving memory: for instance, when a performing a
substitution operation on a term, the subterms that are unaffected
by the substitution are not copied.

One potential disadvantage of \mapendo visitors, in comparison with \map
visitors, is that these runtime tests have a runtime cost. Another
disadvantage is that \mapendo visitors have less general types: in an \mapendo
visitor, the argument type and return type of every method must coincide,
whence the name ``\mapendo''.%
%
\footnote{An endomorphism is a function of a set into itself.}
%
\map visitors are not subject to this restriction: for an illustration, see
\sref{sec:advanced:hashconsed} and \fref{fig:expr14}.

In principle, \mapendo visitors should be created only for immutable data
structures. Although the tool can produce a \mapendo visitor for a mutable
data structure, this is discouraged, as it may lead to unexpected behavior.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr15}
\vspace{-\baselineskip}
\processed{expr15}
\caption{A visitor of the \reduce variety}
\label{fig:expr15}
\end{figure}

\begin{figure}[p]
\origfirstline{expr15b}{3}
\caption{Computing the size of an expression using a \reduce visitor}
\label{fig:reduce}
\end{figure}

\subsection{\reduce visitors}
\label{sec:intro:reduce}

Whereas an \iter visitor returns no result and a \map visitor returns a data
structure, a \reduce visitor returns a ``summary'' of a data structure, so to
speak. The summary of a term is computed by combining the summaries of its
subterms. This requires summaries to inhabit a monoid, that is, a type
equipped with a binary operation \oc|plus| and its neutral element \oc|zero|.

\fref{fig:expr15} shows a \reduce visitor for arithmetic expressions. In
\dataconvisitor{EAdd}, the summaries produced by the two recursive calls are
combined using a call to \oc|self#plus|. In \dataconvisitor{EConst}, there are
no recursive calls, so there is nothing to combine: the result is
\oc|self#zero|.

The virtual methods \oc|zero| and \oc|plus| are declared in the class
\oc|VisitorsRuntime.reduce|, which is automatically inherited. The type of the
monoid elements, at this point, is undetermined: it is up to the
(user-defined) subclasses of the class \reduce to decide what this type should
be and what the monoid operations should be.

As an example application, \fref{fig:reduce} shows how to compute the size of
an expression using a \reduce visitor. We inherit the class \reduce. We also
inherit the class \oc|VisitorsRuntime.addition_monoid|, which defines the
methods \oc|zero| and \oc|plus| as the integer \oc|0| and integer addition,
respectively. There remains to override the method \tyconvisitor{expr} so as
to indicate that every node contributes 1 to the size of an expression.

The size of an expression can also be computed using an \iter visitor equipped
with mutable state, in the style of \fref{fig:expr04}. It is mostly a matter
of style whether such a computation should be performed using \iter or
\reduce.
% TEMPORARY comparer les perfs, pour voir

An \iter visitor is in fact a special case of a \reduce visitor, instantiated
with the \oc|unit| monoid. Thus, in principle, one could forget \iter and
always work with \reduce. Nevertheless, it is preferable to work with \iter
when it is applicable, for reasons of clarity and efficiency.
% e.g. an \iter visitor can traverse a list-like data structure in constant
% stack space; a \reduce visitor cannot, because it does not have an accu.

% One might wonder whether a reduce visitor should have an accumulator...
% ...but then it would be left-to-right-from-the-start, instead of bottom-up.
% I am not sure what we want. Maybe we do not need reduce visitors at all!

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr00fold}
\vspace{-\baselineskip}
\processed{expr00fold}
\caption{A visitor of the \fold variety}
\label{fig:expr00fold}
\end{figure}

\begin{figure}[p]
\orig{fold}
\caption{Converting towards unrelated types using a \fold visitor}
\label{fig:fold}
\end{figure}

\subsection{\fold visitors}
\label{sec:intro:fold}

The varities of visitors presented up to this point differ in the computation
that they perform on the way up, after the recursive calls. As we have seen,
\iter visitors perform no computation at all; \map and \mapendo visitors
reconstruct a term; \reduce visitors perform a series of monoid operations.
Each variety follows a baked-in pattern, which has been programmed ahead of
time, and cannot be changed. What if a different form of computation, which
has not been envisioned by the author of the \visitors syntax extension, is
needed?

This is where \fold visitors come in. A \fold visitor declares virtual methods
that are called on the way up and can be overridden by the user (in a
subclass) so as to implement the desired computation. \fref{fig:expr00fold}
shows a \fold visitor. Two virtual methods, \dataconascendingmethod{EConst}
and \dataconascendingmethod{EAdd}, are declared. They are invoked by
\tyconvisitor{EConst} and \tyconvisitor{EAdd}, respectively.

In a \fold visitor, the return type of the visitor methods is not fixed ahead
of time. It is up to the (user-defined) subclasses of the visitor class to
decide what this type should be.

As an example application, \fref{fig:fold} shows how a \fold visitor can be
used to convert the visited data structure to an entirely different format. In
this example, the type \oc|person| is a record type, whose fields are
\oc|firstname| and \oc|surname|. The type \oc|crowd| is isomorphic to a list
of persons, but, for some reason, it is declared as an algebraic data type
equipped with its own data constructors, \oc|Nobody| and \oc|Someone|. Suppose
we wish to convert a \oc|crowd| to a list of pairs of strings. We can do so by
creating a visitor object that inherits the class \fold and provides concrete
implementations of the methods \tyconascendingmethod{person},
\dataconascendingmethod{Nobody}, and \dataconascendingmethod{Someone}.
Our implementation of \tyconascendingmethod{person} simply allocates
a pair, while our implementations of
\dataconascendingmethod{Nobody} and \dataconascendingmethod{Someone}
respectively build an empty list and a nonempty list.
Thus, the return type of the methods \tyconascendingmethod{person}
and \tyconvisitor{person} is \oc|string * string|,
while the return type of the methods \dataconascendingmethod{Nobody},
\dataconascendingmethod{Someone}, and \dataconvisitor{crowd} is
\oc|(string * string) list|. In a \fold visitor, not all methods
need have the same return type!

If we had chosen to return \oc|f ^ s| instead of \oc|(f, s)| in
\tyconascendingmethod{person}, then a crowd would be converted to
a \oc|string list|. A \fold visitor offers great flexibility.

All previous varieties of visitors are special cases of \fold visitors. The
specialized varieties of visitors are more convenient to use, when they can be
used, because they do not require the user to provide \tyconascendingmethod{}
methods. Yet, \fold visitors are more versatile.

% ppx_tools/genlifter is analogous, with a few differences:
% - it is a command line tool, not as ppx extension;
% - it has only one return type 'res for all methods;
% - the visitor methods receive (as extra arguments)
%   the names of the types, data constructors, and record fields
%   that are being visited.
% - and there are fewer visitor methods, basically one per type,
%   plus one primitive type, plus this#record, this#constr.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr02}
\vspace{-\baselineskip}
\processed{expr02}
\caption{A visitor of the \itertwo variety}
\label{fig:expr02}
\end{figure}
% TEMPORARY note we have declared it concrete because we wish to
% instantiate this class in expr05

\begin{figure}[p]
\orig{expr03}
\vspace{-\baselineskip}
\processed{expr03}
\caption{A visitor of the \maptwo variety}
\label{fig:expr03}
\end{figure}

\subsection{Visitors of arity two}
\label{sec:intro:aritytwo}

The \iter and \map visitors shown so far traverse one tree at a time. There
are situations where one wishes to simultaneously traverse two trees, which
one expects have the same structure. For this purpose, one should use a
visitor of arity 2. These come in two varities, namely \itertwo
(\fref{fig:expr02}) and \maptwo (\fref{fig:expr03}).

In these visitors, the method \tyconvisitor{expr} expects an environment and
two expressions. These expressions must have identical structure: indeed, if
\tyconvisitor{expr} finds that they exhibit different tags at the root, say
\oc|EConst| versus \oc|EAdd|, then it invokes the method \tyconfail{expr},
which by default calls \oc|VisitorsRuntime.fail()|, which throws the exception
\oc|VisitorsRuntime.StructuralMismatch|.

\begin{figure}[t]
\codefollowup{expr02}
\origfirstline{expr05}{3}
\caption{Determining whether two expressions are syntactically equal}
\label{fig:expr05}
\end{figure}

An \itertwo visitor can be used, for instance, to easily determine whether two
expressions are syntactically equal (\fref{fig:expr05}). Naturally, for this
particular purpose, one could use OCaml's primitive equality operator \oc|=|.
Alternatively, one could exploit \ppxderiving and annotate the type definition with
\oc|[@@deriving eq]|. Visitors offer greater flexibility: for instance, if our
arithmetic expressions contained variables, we could easily define an
operation that tests whether two expressions are equal up to a renaming of
variables.
% More generally, if expressions contained variables and binders, we could
% define an operation that tests whether two expressions are $\alpha$-equivalent.

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr06}
\caption{Visitors for a family of types}
\label{fig:expr06}
\end{figure}

\subsection{Visitors for a family of types}
\label{sec:intro:family}

Visitors can be generated not just for one type definition, but for a family
of type definitions. In \fref{fig:expr06}, we propose a definition of
arithmetic expressions that involves three algebraic data types, namely
\oc|unop|, \oc|binop|, and \oc|expr|. We request the generation of two
visitors, namely an \iter visitor and a \map visitor. This causes the
generation of just two classes, named \iter and \map, respectively. Each of
these classes has visitor methods for every type (namely \tyconvisitor{unop},
\tyconvisitor{binop}, \tyconvisitor{expr}) and for every data constructor
(namely \dataconvisitor{UnaryMinus}, \dataconvisitor{BinaryMinus}, and so on).

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr09}
\vspace{-\baselineskip}
\processed{expr09}
\caption{A visitor for a parameterized type of decorated expressions}
\label{fig:expr09}
\end{figure}

\begin{figure}[p]
\codefollowup{expr09}
\origfirstline{expr10}{3}
\caption{Working with different types of decorations}
\label{fig:expr10}
\end{figure}

\subsection{Visitors for parameterized types}
\label{sec:intro:parameterized}

Visitors can be generated for parameterized types, too. (Technically, we
impose a restriction to \emph{regular} types; see \S\ref{sec:regularity}.)
%
In \fref{fig:expr09}, for instance, we define a variant of arithmetic
expressions where every tree node is decorated with a value of type
\oc|'info|. We request the generation of a \map visitor, whose code is shown
in the second part of \fref{fig:expr09}. The generated code has exactly the
same structure as in the previous sections. The only new feature is that the
class \map now has a virtual method, \tyconvisitor{'info}.

% TEMPORARY clarifier qu'on engendre une déclaration de méthode virtuelle
% pour chaque variable de types

% TEMPORARY noter que le type de la méthode virtuelle n'est pas connu de nous,
%    mais est inféré par OCaml

The visitor methods are \emph{not} declared polymorphic in the type
variable~\oc|'info|, or in two type variables~\oc|'info1| and~\oc|'info2|, as
one might perhaps expect. In fact, they must not be declared polymorphic:
indeed, the user who implements \tyconvisitor{'info} in a subclass of \map may
wish to provide an implementation that expects and/or produces specific types
of information.

As a result, a visitor \emph{object} is monomorphic: its method
\tyconvisitor{'info} must have type \oc|info1 ->| \oc|info2| for certain specific
types \oc|info1| and \oc|info2|. Fortunately, the visitor \emph{class} is
polymorphic: therefore, two distinct visitor objects can have distinct types.
% TEMPORARY pointer le fait qu'on peut très bien hériter d'une classe qui
%           contient des méthodes polymorphes.

The class \map is \emph{not} parameterized over the type variable~\oc|'info|,
or over two type variables~\oc|'info1| and~\oc|'info2|, as one might perhaps
expect. This is not necessary.%
\footnote{The class is parameterized over \oc|'self|, and that is sufficient.
  Indeed, the type \oc|'self| determines the type of all methods, including
  \tyconvisitor{'info}. Therefore, \oc|'self| determines \oc|'info|.}
% TEMPORARY documenter plus clairement le fait que toutes nos classes
%           sont paramétrées vis-à-vis du type de 'self,
%           et les classes héritées via [ancestors] doivent suivre cette
%           même convention.

\fref{fig:expr10} presents two example uses of the class \map. In the first
example, we define a function \oc|strip|, of type \oc|'info expr -> unit expr|,
which strips off the decorations in an arithmetic expression, replacing them
with unit values. In the second example, we define a function \oc|number|,
of type \oc|'info expr -> int expr|, which decorates each node in an arithmetic
expression with a unique integer number.%
\footnote{Because the \oc|info| field appears before the \oc|node| field in
  the definition of the type \oc|expr|, and because fields are visited
  left-to-right, we get a prefix numbering scheme. By exchanging these fields,
  we would get postfix numbering.}

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr11}
\vspace{-\baselineskip}
\processed{expr11}
\caption{Dealing with preexisting (parameterized) types, such as \oc|int| and \oc|list|}
\label{fig:expr11}
\end{figure}

\subsection{Dealing with preexisting types}
\label{sec:intro:nonlocal}

A type definition can contain references to the types that are being defined,
also known as \emph{local} types. For instance, in \fref{fig:expr00}, the
definition of \oc|EAdd| contains two references to a local type, namely
\oc|expr|.

A type definition can also contain references to pre-existing types, also
known as \emph{nonlocal} types. For instance, in \fref{fig:expr00}, the
definition of \oc|EConst| contains a reference to a nonlocal type, namely
\oc|int|, which happens to be one of OCaml's primitive types. In
\fref{fig:expr11}, the definition of \oc|EAdd| contains a reference to a
parameterized nonlocal type, namely \oc|list|, which happens to be defined in
OCaml's standard library.

The treatment of local types has been illustrated in the previous sections. In
short, for every local type, a visitor method is called, and is defined:
for instance, for the local type \oc|expr|, we define the (concrete) method
\tyconvisitor{expr}.

The treatment of nonlocal types is the same, except the visitor method is not
defined. It is called, but not defined. Its definition must be provided by an
ancestor class.

% TEMPORARY section à revoir

% TEMPORARY illustrer le traitement des listes; expliquer qu'on peut écrire *à
% la main* un visiteur dont les méthodes sont polymorphes; expliquer via un
% exemple pourquoi c'est utile; noter qu'on ne peut pas engendrer ce visiteur
% car on ne peut engendrer que des méthodes monomorphes

For every OCaml primitive type, the library module \oc|VisitorsRuntime|, which
is automatically opened in the generated code, supplies suitable visitor
classes. The module \oc|VisitorsRuntime| contains several classes named
\oc|iter|, \oc|map|, and so on; each of them supplies methods named
\tyconvisitor{int}, \tyconvisitor{list}, and so on. (Please consult
  \srcFile{VisitorsRuntime.mli} for details.) The generated visitor
automatically inherits from one of these classes, so it gets default
implementations of the methods \tyconvisitor{int}, \tyconvisitor{list},
and so on.

% TEMPORARY document the behavior of [map] at mutable types like ref and array:
% a copy is performed

% ------------------------------------------------------------------------------
% ------------------------------------------------------------------------------

\section{Advanced examples}
% TEMPORARY ou: applications, illustrations?
%           ou: playing with open/closed data types, tying knots, hash-consing?
\label{sec:advanced}

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr12}
\vspace{-\baselineskip}
\processed{expr12}
\caption{An open type of arithmetic expressions} % and a visitor for it
\label{fig:expr12}
\end{figure}
% TEMPORARY also an example of explicit [name]

\begin{figure}[p]
\codefollowup{expr12}
\origfirstline{expr13}{3}
\caption{A closed type of arithmetic expressions}
\label{fig:expr13}
\end{figure}

\begin{figure}[p]
\codefollowup{expr12}
\origfirstline{expr08}{3}
\caption{A closed type of hash-consed arithmetic expressions}
\label{fig:expr08}
\end{figure}

\subsection{Visitors for open and closed data types}
\label{sec:advanced:openclosed}

The algebraic data types of arithmetic expressions shown in the previous
section (\sref{sec:intro}) are \emph{closed}. That is, the type \oc|expr|
is recursive: an expression of type \oc|expr| has subexpressions of type
\oc|expr|.

It is often desirable, for greater flexibility, to first define an \emph{open}
type of arithmetic expressions. Such a type, say \oc|oexpr|, is parameterized
over a type variable~\oc|'expr|. It is nonrecursive: an expression of type
\oc|'expr oexpr| has subexpressions of type \oc|'expr|. It is shown in
\fref{fig:expr12}. Naturally, we may request the generation of visitors for
the type \oc|oexpr|. In \fref{fig:expr12}, we generate a class of \map
visitors, which we name \oc|omap|. As explained earlier
(\sref{sec:intro:parameterized}), this class has a virtual method,
\tyconvisitor{'expr}.

The closed (recursive) type of expressions, \oc|expr|, can then be defined in
terms of \oc|expr|. This is done in \fref{fig:expr13}. In type-theoretical
terms, one would like to define \oc|expr| as the fixed point of the functor
\oc|oexpr|.
% TEMPORARY citation; demander à Pierre-Évariste
That is, roughly speaking, one would like to define \oc|type expr = expr oexpr|.
This is not accepted by OCaml, though;%
%
\footnote{It would be accepted by OCaml with the command line switch
  \texttt{-rectypes}, which instructs the typechecker to tolerate
  equirecursive types. However, this is \emph{not} a good idea, as it causes
  the typechecker to suddenly accept many meaningless programs and infer
  bizarre types for them.}
%
we work around this limitation by making \oc|expr| an algebraic data type
whose single data constructor is named~\oc|E|.%
%
\footnote{We mark this algebraic data type \oc|[@@unboxed]|, which (as of
  OCaml 4.04) guarantees that there is no runtime cost associated with the
  data constructor~\oc|E|. A value of type \oc|expr| is represented at
  runtime as a value of type \oc|expr oexpr|.}

Let us now construct a visitor class for the type \oc|expr|. It is easy to
do so, by hand, in a few lines of code.%
%
\footnote{We could request the generation of a visitor class via a
  \oc|[@@deriving]| annotation. However, the type \oc|oexpr| would then be
  viewed as nonlocal; therefore, we would have to first define a visitor
  function \oc|Oexpr.map| for the type \oc|oexpr|. That could be done. More
  seriously, the generated visitor class would have only one method, namely
  \tyconvisitor{expr}, so it would not be customizable by inheritance, as it
  should be.}
%
We define a class \oc|map|, a subclass of \oc|omap|, and provide a concrete
implementation of the virtual method \tyconvisitor{'expr}. In the definition
of the type \oc|expr|, the type variable \oc|'expr| is instantiated with
\oc|expr|, so the method \tyconvisitor{'expr} expects an argument of type
\oc|expr| and must return a result of type \oc|expr|. We deconstruct the
argument using the pattern \oc|E e|. Therefore, the variable \oc|e| has type
\oc|expr oexpr| and is a suitable argument to the method \tyconvisitor{oexpr}.
After this call, we perform the same step in reverse: the result of the call
has type \oc|expr oexpr|, so we wrap it in an application of the data
constructor~\oc|E| and obtain a result of type \oc|expr|.

The visitor class \oc|map| can now be used to implement transformations of
arithmetic expressions, that is, functions of type \oc|expr -> expr|. As an
example, let us implement a transformation whose effect is to double every
integer constant in an arithmetic expression. This is done in
\fref{fig:expr13double}. As expected, it suffices to construct a visitor
object that inherits \oc|map| and overrides the method
\dataconvisitor{EConst}.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\codefollowupgeneral{Figures~\ref{fig:expr12} and \ref{fig:expr13}}
\origfirstline{expr13double}{4}
\caption{A transformation of ordinary arithmetic expressions}
\label{fig:expr13double}
\end{figure}

\begin{figure}[p]
\codefollowupgeneral{Figures~\ref{fig:expr12} and \ref{fig:expr08}}
\origfirstline{expr08double}{4}
\caption{A transformation of hash-consed arithmetic expressions}
\label{fig:expr08double}
\end{figure}

\begin{figure}[p]
\codefollowupgeneral{Figures~\ref{fig:expr12}, \ref{fig:expr13}, and~\ref{fig:expr08}}
\origfirstline{expr14}{6}
\caption{Conversions between ordinary and hash-consed arithmetic expressions}
\label{fig:expr14}
\end{figure}

\subsection{Visitors for hash-consed abstract syntax trees}
\label{sec:advanced:hashconsed}

On top of the open data type \oc|oexpr| of the previous section
(\sref{sec:advanced:openclosed}), one can define not just the closed data type
\oc|expr| of ordinary arithmetic expressions, but also other closed data types
of expressions where every node is annotated with information.

As an example, let us define a type \oc|hexpr| of hash-consed (that is,
maximally-shared) arithmetic expressions. We use Filliâtre and Conchon's
library~\cite{filliatre-conchon-06}, which can be found in \opam under the
name \hashcons.

The definition of the type \oc|hexpr| appears in \fref{fig:expr08}. It is
analogous to the definition of the type \oc|expr| (\fref{fig:expr13}), with an
added twist: instead of taking the fixed point of the functor \oc|_ oexpr|, we
take the fixed point of the functor \oc|_ oexpr hash_consed|. By looking up
the definition of the type \oc|hash_consed| in \hashconsRepoFile{hashcons.mli},
one finds that this means that every node in an arithmetic expression carries
certain information (namely a unique tag and a hash) that are used to enforce
maximal sharing.

Enforcing maximal sharing requires maintaining a mutable table where all
arithmetic expressions ever constructed are stored. (This is in fact a weak
hash table.) We initialize such a table by calling the function
\oc|Hashcons.create|. This table is then populated by the function \oc|h|, a smart
constructor.
% of type \oc|hexpr oexpr -> hexpr|.
This function takes a candidate expression of type \oc|hexpr oexpr| and
returns an expression of type \oc|hexpr|, which is either allocated anew
or found in the table (should an identical expression already exist).

We can now construct a visitor class for the type \oc|hexpr|. As in the previous
section (\sref{sec:advanced:openclosed}), we do so by hand in a few lines of code.
%
% Our reasons for writing this code by hand are the same as in the previous
% section. Furthermore, we note that the code of the visitor refers to the
% function~\oc|h|, thus depends on \oc|table|. The definition of \oc|table|
% itself must come after the definition of the type \oc|hexpr|, since the
% type of \oc|table| is \oc|hexpr oexpr Hashcons.t|. For this reason, we
% cannot use [@@deriving] to generate the visitor just after the type
% definition.
%
% That said, since the visitor depends on \oc|h| and not directly on \oc|table|,
% we could cut the dependency by going through the store. Create a reference to
% a function of type \oc|hexpr oexpr -> hexpr|. Initialize it with a dummy
% function. Generate the visitor. Then, create the table, define \oc|h| and
% update the reference. Ugh.
%
The overall structure of this code is the same as in \fref{fig:expr13}. The
only difference is that the method \tyconvisitor{'expr} must now traverse
two levels of type structure, corresponding to \oc|_ oexpr hash_consed|.
It deconstructs this structure by using the pattern \oc|H { node = e ; _ }|,%
%
\footnote{The \oc|node| field is part of the record type \oc|hash_consed|;
see \hashconsRepoFile{hashcons.mli}.}
%
and reconstructs it by applying the smart constructor~\oc|h|.

A function \oc|double| can be defined for hash-consed arithmetic expressions
in exactly the same manner as we defined \oc|double| for ordinary arithmetic
expressions: compare \fref{fig:expr13double} and \fref{fig:expr08double}.
%
% In fact, although we did not attempt to share the code of the method
% \dataconvisitor{EConst} between these two figures, one could do so if
% desired, by exploiting multiple inheritance.
%

The visitor class \oc|omap| for open arithmetic expressions
(\fref{fig:expr12}) can be exploited to define conversions
between different types of arithmetic expressions.
This is illustrated in \fref{fig:expr14}.
There, the function \oc|import| converts an ordinary expression
to a hash-consed expression, thereby imposing maximal sharing.
Conversely, the function \oc|export| converts a hash-consed
expression into an ordinary expression, thereby abandoning
all sharing (therefore possibly causing an exponential explosion).
The implementation of these functions is simple: it is just
a matter of overriding \tyconvisitor{'expr} so as to deconstruct
one kind of expression and reconstruct the other kind.

% ------------------------------------------------------------------------------

\bibliographystyle{plain}
\bibliography{english}

\end{document}

% TEMPORARY

document the speed overhead compared to a native recursive function

document how to see the preprocessed code

document how to see its inferred type
  explain why we do not work in .mli files
  we cannot predict the types of the generated methods,
    because it depends on the types of the ancestor classes
  the generator is type-agnostic
    and although that may deemed disappointing,
    it is also the key reason why it is so simple and versatile
  show inferred types in the manual?
    tricky: many private methods
            a redundant constraint

document that non-regular ADTs are not supported
  existential types, GADTs not supported either
  that would require polymorphic methods

document @opaque
  careful with map2: an arbitrary choice takes place

list which types forms are unsupported
document how to deal with unsupported types
  wrap them in @opaque
  or replace them with type variables
  note the user can define their own opaque-like parameterized types
    and actually perform nontrivial treatment of the data of unsupported type
  could do HOAS as an example!
also unsupported: existential types, GADTs

document the OCaml object tricks that are used
  1. normally, unbound variables in method types are disallowed;
     one must make them parameters of the class (see OCaml manual)
     here, every class is parameterized over ['self]
     which allows all method types to be inferred (including virtual methods)
  2. methods are monomorphic, but class can be polymorphic
  3. can inherit classes that provide polymorphic methods
     i.e., user can supply code both a priori (by providing ancestor classes)
           and a posteriori (by defining child classes after the fact)
  4. can hide private methods in the signature
  -- anything else?
  -- the lazy-initializer trick, if used

référence:
  document the regularity restriction \label{sec:regularity} and the option irregular
  document all options
  document the option concrete
  document public
  avoid shadowing the following names: VisitorsRuntime, Lazy, Pervasives
  document which builtin types are supported by VisitorsRuntime
  document which OCaml types can/cannot be traversed

related work, for OCaml:
  ppx_deriving (generates monolithic code) (fixed number of templates)
  ppx_deriving_morphism
  Hongbo Zhang has `deriving at a distance' in Fan
    https://github.com/bobzhang/fan
    http://zhanghongbo.me/fan/
    http://zhanghongbo.me/fan/_downloads/metaprogramming_for_ocaml.pdf
  alphaCaml

related work, for other programming languages:
  Bound (Edward Kmett)
  Unbound (Weirich)
  RedPerl
  Francisco Ferreira et Brigitte Pientka, ESOP 2017 (Babybel)

related work, for proof assistants:
  Steven Keuchel
  Autosubst (voir Kaiser et al., CPP 2017)
  voir Guillaume Allais (CPP 2017, Agda et Haskell) et Goguen & McKinna

crazy title ideas:
  Dr Boilerplate, or: how I learned to stop worrying and love bound names
