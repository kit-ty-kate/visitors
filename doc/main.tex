\documentclass[11pt,a4paper,twoside]{article}
\usepackage[left=25mm,right=25mm,top=25mm,bottom=25mm,marginparwidth=50pt]{geometry}
\setlength\abovecaptionskip{0pt} % Reduce space above figure captions.
\usepackage{lmodern} % This gives us a bold monospace font.
\renewcommand{\rmdefault}{ptm} % Times.
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[bookmarks=true,bookmarksopen=true,colorlinks=true,%
            linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\usepackage{marginnote}
\usepackage{listings}
\input{listings-ocaml}
\lstset{language=ocaml}
\usepackage{moreverb}
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage{xspace}
\input{macros}
% Style.
\renewcommand{\emph}[1]{\textbf{#1}}
\input{version}

% TEMPORARY vérifier placement et enchaînement des figures

% ------------------------------------------------------------------------------
% Headings.

\title{Visitors\\\normalsize version \visitorsversion}
\date{}
\begin{document}
\author{François Pottier\\ Inria Paris\\ \email{francois.pottier@inria.fr}}
\maketitle

% ------------------------------------------------------------------------------

\clearpage
\tableofcontents
\clearpage

% ------------------------------------------------------------------------------

\begin{flushright}
  Les visites font toujours plaisir, si ce n'est en arrivant, du moins en
  partant. \\ --- \textit{Jean de La Bruyère}
\end{flushright}

\vspace{1cm}

% ------------------------------------------------------------------------------
% ------------------------------------------------------------------------------

\section{Introduction}
\label{sec:intro}

% ------------------------------------------------------------------------------

\subsection{What is a visitor?}

A visitor for a data structure is a class whose methods implement a traversal
of this data structure. By default, the visitor methods do not have
interesting behavior: they just cause control to go down into the data
structure and come back up, without performing any actual computation.
Nevertheless, by defining subclasses where one method or a few methods are
overridden, nontrivial behavior can be obtained. Therefore, visitors allow
many operations on this data structure to be defined with little effort.

Visitors come in several varieties. An \iter visitor traverses a data
structure and returns no result. It can nevertheless have side effects,
including updating a piece of mutable state, raising an exception, and
performing input/output. A \map visitor traverses a data structure and returns
another data structure: typically, a copy of its argument that has been
transformed in some way. A \reduce visitor traverses a data structure and
returns a value that somehow summarizes it: computing the size of a data
structure is a typical example. Finally, as it is sometimes necessary to
simultaneously traverse two data structures of identical shape, there are
visitors of arity two: we refer to them as \itertwo, \maptwo, and \reducetwo
visitors.

% ------------------------------------------------------------------------------

\subsection{What does this package offer?}

Visitors have extremely regular structure. As a result, whereas implementing
them by hand is boring and error-prone, generating them automatically is often
possible. The \visitors package extends the syntax of OCaml%
%
\footnote{Technically, \visitors is a plugin for \ppxderiving, which itself is
  a preprocessor extension for the OCaml compiler.}
%
so as to make it easy for the programmer to request the automatic generation
of visitor classes. Visitor classes for many forms of user-defined data types
can be generated and, if necessary, combined (via multiple inheritance) with
hand-written visitor classes, making the framework quite powerful.

% ------------------------------------------------------------------------------
% ------------------------------------------------------------------------------

\section{Walkthrough}

% ------------------------------------------------------------------------------

\subsection{Setup}
\label{sec:intro:setup}

In order to install the \visitors package, an \opam user should issue the
following commands:
\begin{verbatim}
  opam update
  opam install visitors
\end{verbatim}
To use the package, an \ocamlbuild user should add the
following line in her project's \texttt{\_tags} file:
\begin{lstlisting}
  true: package(visitors.ppx), package(visitors.runtime)
\end{lstlisting}
Finally, a user of \merlin should add the following lines in her project's
\texttt{.merlin} file:
\begin{lstlisting}
  PKG visitors.ppx
  PKG visitors.runtime
\end{lstlisting}

% ------------------------------------------------------------------------------

\begin{figure}[t]
% In an OCaml source file, a type definition can be annotated with
% \oc|[@@deriving visitors { ... }]|:
\orig{expr00}
% This causes the following code to be (invisibly) generated:
\vspace{-\baselineskip}
\processed{expr00}
\caption{A visitor of the \iter variety}
\label{fig:expr00}
\end{figure}

\subsection{Defining an \iter visitor}
\label{sec:intro:iter:def}

Suppose we need to manipulate arithmetic expressions built out of integer
literals and binary additions. The abstract syntax of these expressions can be
described by an algebraic data type \oc|expr|, shown in the first part of
\fref{fig:expr00}.
%
By annotating this type definition with \oc|[@@deriving visitors { ... }]|, we
request the automated generation of a visitor for expressions. The annotation
\oc|[@@deriving visitors| \oc|{ ... }]| must carry at least one parameter,
\variety, which indicates what variety of visitor is desired.

The code of the visitor class, which is automatically generated and in normal
use remains invisible, is shown in the second part of \fref{fig:expr00}. The
name of this class is by default the value of the \variety parameter. It can
be changed, if desired, by explicitly supplying a \name parameter.

A visitor takes the form of an OCaml class, whose methods are named after the
types and data constructors that appear in the type definition. In
\fref{fig:expr00}, for instance, the method \tyconvisitor{expr} is named after
the type \oc|expr|, while the methods \dataconvisitor{EConst} and
\dataconvisitor{EAdd} are named after the data constructors \oc|EConst| and
\oc|EAdd|.

Different varieties of visitors differ in the computation that is performed
``on the way up'', after the recursive calls have finished, therefore differ
in the return types of the visitor methods. \iter is the simplest variety. An
\iter visitor performs no computation on the way up, so its methods have
return type \oc|unit|.

In an \iter visitor, the generated visitor methods do nothing. In
\fref{fig:expr00}, for instance, the method \tyconvisitor{expr} inspects its
argument \oc|this| and recursively invokes either \dataconvisitor{EConst} or
\dataconvisitor{EAdd}, as appropriate. The method \dataconvisitor{EConst} does
nothing.\footnote{More precisely, it calls the method \tyconvisitor{int},
  which is inherited from the class \oc|VisitorsRuntime.iter|, and does
  nothing. This call to \tyconvisitor{int} can be avoided, if desired, by using
  \oc|(int[@opaque])| instead of \oc|int|; see \sref{sec:opaque}.} The method
\dataconvisitor{EAdd} performs two recursive calls to \tyconvisitor{expr},
which does nothing, so \dataconvisitor{EAdd} itself does nothing.

Every method is parameterized with an environment \oc|env|, which is carried
down into every recursive call and is otherwise unused. The type of this
environment is undetermined: it is up to the (user-defined) subclasses of the
visitor class to decide what the type of \oc|env| should be and (possibly)
where and how this environment should be enriched.

% One could note that the visitor class is parameterized over 'self,
% but it is perhaps a bit early for such a remark.

The fields of a data constructor or record are traversed left to right, in the
order they are declared. In a list-like data structure, the field that holds a
pointer to the list tail should be declared last, so as to ensure that the
traversal requires constant stack space.

% ------------------------------------------------------------------------------

\begin{figure}[t]
\codefollowup{expr00}
\origfirstline{expr04}{3}
\caption{Counting the number of addition nodes in an expression}
\label{fig:expr04}
\end{figure}

\subsection{Using an \iter visitor}
\label{sec:intro:iter:usage}

Naturally, traversing a data structure without actually computing anything is
not a very sensible thing to do. Things become interesting when at least one
visitor method is overridden so as to give rise to nontrivial behavior.
Suppose, for instance, that we wish to count the number of addition nodes in
an expression. This can be done as shown in \fref{fig:expr04}. We create an
object~\oc|v| that is both a counter (that is, an object equipped with a
mutable field~\oc|count|) and a visitor, and we override its method
\dataconvisitor{EAdd} so that the counter is incremented every time this
method is invoked. There remains to run the visitor, by invoking its
\tyconvisitor{expr} method, and to return the final value of the counter. The
environment, in this example, is unused; we let it have type \unit.

This may seem a rather complicated way of counting the addition nodes in an
expression. Of course, one could give a direct recursive definition of the
function \oc|count|, in a few lines of code, without using a visitor at all.
The point of employing a visitor, as done in Figures~\ref{fig:expr00}
and~\ref{fig:expr04}, is that no changes to the code are required when the
type of expressions is extended with new cases.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr01}
\vspace{-\baselineskip}
\processed{expr01}
\caption{A visitor of the \map variety}
\label{fig:expr01}
\end{figure}

\subsection{\map visitors}
\label{sec:intro:map}

An \iter visitor returns no result. Although, as illustrated previously
(\sref{sec:intro:iter:usage}), it can use private mutable state to accumulate
information, there are applications for which such a visitor is not suitable.
One class of such applications is tree transformations. To transform an
expression into an expression, one should use a visitor of another variety,
namely \map.

A \map visitor is shown in \fref{fig:expr01}. In comparison with the \iter
visitor of \fref{fig:expr00}, the generated code is identical, except that,
instead of returning the unit value \oc|()|, the method
\dataconvisitor{EConst} reconstructs an \oc|EConst| expression, while the
method \dataconvisitor{EAdd} reconstructs an \oc|EAdd| expression.

A \map visitor behaves (by default) as an identity function: it constructs a
copy of the data structure that it visits. If the data structure is immutable,
this is rather pointless: in order to obtain nontrivial behavior, at least one
method should be overridden. In the data structure is mutable, though, even
the default behavior is potentially of interest: it constructs a deep copy of
its argument.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr00endo}
\vspace{-\baselineskip}
\processed{expr00endo}
\caption{A visitor of the \mapendo variety}
\label{fig:expr00endo}
\end{figure}

\subsection{\mapendo visitors}
\label{sec:intro:endo}

\mapendo visitors are a slight variation of \map visitors. Whereas a \map
visitor systematically allocates a copy of the memory block that it receives
as an argument, an \mapendo visitor (\fref{fig:expr00endo}) first tests if the
newly allocated block would have exactly the same contents as the original
block, and if so, re-uses the original block instead.
% Didier attributes this idea to Gérard Huet,
% at least in the case of a dictionary insertion operation,
% where Gérard would raise an exception so as to go back to
% the toplevel and avoid re-allocating a path.

This trick allows saving memory: for instance, when a performing a
substitution operation on a term, the subterms that are unaffected
by the substitution are not copied.

One potential disadvantage of \mapendo visitors, in comparison with \map
visitors, is that these runtime tests have a runtime cost. Another
disadvantage is that \mapendo visitors have less general types: in an \mapendo
visitor, the argument type and return type of every method must coincide,
whence the name ``\mapendo''.%
%
\footnote{An endomorphism is a function of a set into itself.}
%
\map visitors are not subject to this restriction: for an illustration, see
\sref{sec:advanced:hashconsed} and \fref{fig:expr14}.

In principle, \mapendo visitors should be created only for immutable data
structures. Although the tool can produce a \mapendo visitor for a mutable
data structure, this is discouraged, as it may lead to unexpected behavior.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr15}
\vspace{-\baselineskip}
\processed{expr15}
\caption{A visitor of the \reduce variety}
\label{fig:expr15}
\end{figure}

\begin{figure}[p]
\codefollowup{expr15}
\origfirstline{expr15b}{3}
\caption{Computing the size of an expression using a \reduce visitor}
\label{fig:reduce}
\end{figure}

\subsection{\reduce visitors}
\label{sec:intro:reduce}

Whereas an \iter visitor returns no result and a \map visitor returns a data
structure, a \reduce visitor returns a ``summary'' of a data structure, so to
speak. The summary of a term is computed by combining the summaries of its
subterms. This requires summaries to inhabit a monoid, that is, a type
equipped with a binary operation \oc|plus| and its neutral element \oc|zero|.

\fref{fig:expr15} shows a \reduce visitor for arithmetic expressions. In
\dataconvisitor{EAdd}, the summaries produced by the two recursive calls are
combined using a call to \oc|self#plus|. In \dataconvisitor{EConst}, there are
no recursive calls, so there is nothing to combine: the result is
\oc|self#zero|.

The virtual methods \oc|zero| and \oc|plus| are declared in the class
\oc|VisitorsRuntime.reduce|, which is automatically inherited. The type of the
monoid elements, at this point, is undetermined: it is up to the
(user-defined) subclasses of the class \reduce to decide what this type should
be and what the monoid operations should be.

As an example application, \fref{fig:reduce} shows how to compute the size of
an expression using a \reduce visitor. We inherit the class \reduce. We also
inherit the class \oc|VisitorsRuntime.addition_monoid|, which defines the
methods \oc|zero| and \oc|plus| as the integer \oc|0| and integer addition,
respectively. There remains to override the method \tyconvisitor{expr} so as
to indicate that every node contributes 1 to the size of an expression.

Incidentally, this code is written in such a manner that a single visitor
object is created initially and serves in every call to the function
\oc|size|. This style can be used when the visitor object is immutable and
when the function that one wishes to define is monomorphic. When it cannot be
used, one begins with \oc|let size (e : expr) : int = ...| and ends with %
\oc|v # visit_expr () e|. That style causes a new visitor object to be created
every time \oc|size| is called.
% On pourrait ré-utiliser le même objet à chaque fois en remettant son champ à
% zéro... Mais ce serait sale et pas ré-entrant.

The size of an expression can also be computed using an \iter visitor equipped
with mutable state, in the style of \fref{fig:expr04}. It is mostly a matter
of style whether such a computation should be performed using \iter or
\reduce.
% TEMPORARY comparer les perfs, pour voir

An \iter visitor is in fact a special case of a \reduce visitor, instantiated
with the \oc|unit| monoid. Thus, in principle, one could forget \iter and
always work with \reduce. Nevertheless, it is preferable to work with \iter
when it is applicable, for reasons of clarity and efficiency.
% e.g. an \iter visitor can traverse a list-like data structure in constant
% stack space; a \reduce visitor cannot, because it does not have an accu.

% One might wonder whether a reduce visitor should have an accumulator...
% ...but then it would be left-to-right-from-the-start, instead of bottom-up.
% I am not sure what we want. Maybe we do not need reduce visitors at all!

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr00fold}
\vspace{-\baselineskip}
\processed{expr00fold}
\caption{A visitor of the \fold variety}
\label{fig:expr00fold}
\end{figure}

\begin{figure}[p]
\orig{fold}
\caption{Converting towards unrelated types using a \fold visitor}
\label{fig:fold}
\end{figure}

\subsection{\fold visitors}
\label{sec:intro:fold}

The varities of visitors presented up to this point differ in the computation
that they perform on the way up, after the recursive calls. As we have seen,
\iter visitors perform no computation at all; \map and \mapendo visitors
reconstruct a term; \reduce visitors perform a series of monoid operations.
Each variety follows a baked-in pattern, which has been programmed ahead of
time, and cannot be changed. What if a different form of computation, which
has not been envisioned by the author of the \visitors syntax extension, is
needed?

This is where \fold visitors come in. A \fold visitor declares virtual methods
that are called on the way up and can be overridden by the user (in a
subclass) so as to implement the desired computation. \fref{fig:expr00fold}
shows a \fold visitor. Two virtual methods, \dataconascendingmethod{EConst}
and \dataconascendingmethod{EAdd}, are declared. They are invoked by
\tyconvisitor{EConst} and \tyconvisitor{EAdd}, respectively.

In a \fold visitor, the return type of the visitor methods is not fixed ahead
of time. It is up to the (user-defined) subclasses of the visitor class to
decide what this type should be.

As an example application, \fref{fig:fold} shows how a \fold visitor can be
used to convert the visited data structure to an entirely different format. In
this example, the type \oc|person| is a record type, whose fields are
\oc|firstname| and \oc|surname|. The type \oc|crowd| is isomorphic to a list
of persons, but, for some reason, it is declared as an algebraic data type
equipped with its own data constructors, \oc|Nobody| and \oc|Someone|. Suppose
we wish to convert a \oc|crowd| to a list of pairs of strings. We can do so by
creating a visitor object that inherits the class \fold and provides concrete
implementations of the methods \tyconascendingmethod{person},
\dataconascendingmethod{Nobody}, and \dataconascendingmethod{Someone}.
Our implementation of \tyconascendingmethod{person} simply allocates
a pair, while our implementations of
\dataconascendingmethod{Nobody} and \dataconascendingmethod{Someone}
respectively build an empty list and a nonempty list.
Thus, the return type of the methods \tyconascendingmethod{person}
and \tyconvisitor{person} is \oc|string * string|,
while the return type of the methods \dataconascendingmethod{Nobody},
\dataconascendingmethod{Someone}, and \dataconvisitor{crowd} is
\oc|(string * string) list|. In a \fold visitor, not all methods
need have the same return type!

If we had chosen to return \oc|f ^ s| instead of \oc|(f, s)| in
\tyconascendingmethod{person}, then a crowd would be converted to
a \oc|string list|. A \fold visitor offers great flexibility.

All previous varieties of visitors are special cases of \fold visitors. The
specialized varieties of visitors are more convenient to use, when they can be
used, because they do not require the user to provide \tyconascendingmethod{}
methods. Yet, \fold visitors are more versatile.

% ppx_tools/genlifter is analogous, with a few differences:
% - it is a command line tool, not as ppx extension;
% - it has only one return type 'res for all methods;
% - the visitor methods receive (as extra arguments)
%   the names of the types, data constructors, and record fields
%   that are being visited.
% - and there are fewer visitor methods, basically one per type,
%   plus one primitive type, plus this#record, this#constr.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr02}
\vspace{-\baselineskip}
\processed{expr02}
\caption{A visitor of the \itertwo variety}
\label{fig:expr02}
\end{figure}

\begin{comment}
\begin{figure}[p]
\orig{expr03}
\vspace{-\baselineskip}
\processed{expr03}
\caption{A visitor of the \maptwo variety}
\label{fig:expr03}
\end{figure}
\end{comment}

\subsection{Visitors of arity two}
\label{sec:intro:aritytwo}

The visitors introduced so far traverse one tree at a time. There are
situations where one wishes to simultaneously traverse two trees, which one
expects have the same structure. For this purpose, one can use a visitor of
arity 2. Every variety except \mapendo is available at arity 2.

As an illustration, \fref{fig:expr02} shows an \itertwo visitor. There, the
method \tyconvisitor{expr} expects an environment and two expressions. These
expressions must have identical structure: indeed, if \tyconvisitor{expr}
finds that they exhibit different tags at the root, say \oc|EConst| versus
\oc|EAdd|, then it invokes the method \tyconfail{expr}, whose default
implementation calls the function \oc|VisitorsRuntime.fail|. This function
throws the exception \oc|VisitorsRuntime.StructuralMismatch|.

In \fref{fig:expr02}, we have added the optional parameter
%
\oc|concrete = true|
%
to indicate that the generated class should not be virtual. (By default,
every generated class is declared \oc|virtual|.) We do this because, in
the illustration that follows, we wish to instantiate this class.

\begin{figure}[p]
\codefollowup{expr02}
\origfirstline{expr05}{3}
\caption{Determining whether two expressions are syntactically equal}
\label{fig:expr05}
\end{figure}

As an illustration, in \fref{fig:expr05}, we use an \itertwo visitor to write
a function that tests whether two expressions are syntactically equal. This is
just a matter of performing a synchronous traversal of the two expressions and
detecting a \oc|StructuralMismatch| exception: if this exception is raised,
one must return \oc|false|, otherwise one must return \oc|true|. We rely on
the fact that the method \tyconvisitor{int}, which is inherited from the class
\oc|VisitorsRuntime.iter2|, fails when when its two integer argument are
unequal.

The convenience functions \oc|VisitorsRuntime.wrap| and
\oc|VisitorsRuntime.wrap2| run a user-supplied function (of arity 1 or 2,
respectively) within an exception handler and return a Boolean result, which
is \oc|true| if no exception was raised. Here, we run the function
%
\oc|new iter2 # visit_expr ()|, whose type is \oc|expr -> expr -> unit|,
in the scope of such a handler.

Naturally, to test whether two expressions are syntactically equal, one could
also use the primitive equality operator \oc|=|. Alternatively, one could
exploit \ppxderiving and annotate the type definition with
%
\oc|[@@deriving eq]|. Visitors offer greater flexibility: for instance, if our
arithmetic expressions contained variables and binders, we could easily define
an operation that tests whether two expressions are $\alpha$-equivalent.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr06}
\caption{Visitors for a family of types}
\label{fig:expr06}
\end{figure}

\subsection{Visitors for a family of types}
\label{sec:intro:family}

Visitors can be generated not just for one type definition, but for a family
of type definitions. In \fref{fig:expr06}, we propose a definition of
arithmetic expressions that involves three algebraic data types, namely
\oc|unop|, \oc|binop|, and \oc|expr|. We request the generation of two
visitors, namely an \iter visitor and a \map visitor. This causes the
generation of just two classes, named \iter and \map, respectively. Each of
these classes has visitor methods for every type (namely \tyconvisitor{unop},
\tyconvisitor{binop}, \tyconvisitor{expr}) and for every data constructor
(namely \dataconvisitor{UnaryMinus}, \dataconvisitor{BinaryMinus}, and so on).

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr09}
\vspace{-\baselineskip}
\processed{expr09}
\caption{A visitor for a parameterized type of decorated expressions}
\label{fig:expr09}
\end{figure}

\begin{figure}[p]
\codefollowup{expr09}
\origfirstline{expr10}{3}
\caption{Working with different types of decorations}
\label{fig:expr10}
\end{figure}

\subsection{Visitors for parameterized types}
\label{sec:intro:parameterized}

Visitors can be generated for parameterized types, too.%
%
\footnote{Technically, we impose a restriction to regular types; see
  \S\ref{sec:regularity}.}
%
In \fref{fig:expr09}, for instance, we define a variant of arithmetic
expressions where every tree node is decorated with a value of type
\oc|'info|. We request the generation of a \map visitor, whose code is shown
in the second part of \fref{fig:expr09}. The generated code has exactly the
same structure as in the previous sections. The only new feature is that the
class \map now has a virtual method, \tyconvisitor{'info}. The general rule
is, for each type parameter, there is one virtual method, named after it.

The visitor methods are \emph{not} declared polymorphic in a type
variable~\oc|'info|, or in two type variables \oc|'info1|~and~\oc|'info2|, as
one might perhaps expect. In fact, they must not be declared polymorphic:
indeed, the user who implements \tyconvisitor{'info} in a subclass of \map may
wish to provide an implementation that expects and/or produces specific types
of information.

As a result, a visitor \emph{object} is monomorphic: its method
\tyconvisitor{'info} must have type \oc|info1 ->| \oc|info2| for certain
specific types \oc|info1| and \oc|info2|. Fortunately, because it is
parameterized over \oc|'self|,\footnote{We explain in \sref{sec:oo:self} why
  all visitor classes are parameterized over \oc|'self|.} the visitor
\emph{class} is polymorphic: two distinct visitor objects can have distinct
types.

Although every \emph{automatically generated} method
is monomorphic, a visitor class can nevertheless \emph{inherit} polymorphic
methods from a parent class, whose name is specified via the \ancestors parameter
(\sref{sec:ancestors}). For instance, the \tyconvisitor{list} methods provided by
the classes \oc|VisitorsRuntime.iter|, \oc|VisitorsRuntime.map|, and so on, are
polymorphic in the types of the list elements. (See \sref{sec:intro:nonlocal}
for more information on the treatment of preexisting types.)

\fref{fig:expr10} presents two example uses of the class \map defined in
\fref{fig:expr09}. In the first example, we define a function \oc|strip|, of
type \oc|'info expr -> unit expr|, which strips off the decorations in an
arithmetic expression, replacing them with unit values. In the second example,
we define a function \oc|number|, of type \oc|'info expr -> int expr|, which
decorates each node in an arithmetic expression with a unique integer number.%
\footnote{Because the \oc|info| field appears before the \oc|node| field in
  the definition of the type \oc|expr|, and because fields are visited
  left-to-right, we get a prefix numbering scheme. By exchanging these fields,
  we would get postfix numbering.} %

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr11}
\vspace{-\baselineskip}
\processed{expr11}
\caption{Dealing with preexisting (parameterized) types, such as \oc|int| and \oc|list|}
\label{fig:expr11}
\end{figure}

\subsection{Dealing with preexisting types}
\label{sec:intro:nonlocal}

A type definition can contain references to the types that are being defined,
also known as \emph{local} types. For instance, in \fref{fig:expr00}, the
definition of \oc|EAdd| contains two references to a local type, namely
\oc|expr|.

A type definition can also contain references to preexisting types, also
known as \emph{nonlocal} types. For instance, in \fref{fig:expr00}, the
definition of \oc|EConst| contains a reference to a nonlocal type, namely
\oc|int|, which happens to be one of OCaml's primitive types. In
\fref{fig:expr11}, the definition of \oc|EAdd| contains a reference to a
parameterized nonlocal type, namely \oc|list|, which happens to be defined in
OCaml's standard library.

The treatment of local types has been illustrated in the previous sections. In
short, for every local type, a visitor method is called, and is defined:
for instance, for the local type \oc|expr|, we define the (concrete) method
\tyconvisitor{expr}.

The treatment of nonlocal types is the same, except the visitor method is not
defined, nor declared. That is, it is called, but is neither defined (as a
concrete method) or declared (as a virtual method). Therefore, its definition
must be provided by an ancestor class.

For most of OCaml primitive or built-in types, support is provided by the
module \oc|VisitorsRuntime|. This module contains several classes named
\oc|iter|, \oc|map|, and so on; each of them supplies methods named
\tyconvisitor{int}, \tyconvisitor{list}, and so on.%
%
\footnote{As an exception to this rule, the classes \oc|VisitorsRuntime.fold|
  and \oc|VisitorsRuntime.fold2| do not supply any methods, because we do not
  wish to prematurely fix the types of the visitor methods. Please consult
  \srcFile{VisitorsRuntime.ml} to check which methods exist and what they
  do.} %
%
As is evident in Figures~\ref{fig:expr00}, \fref{fig:expr01}, and so on, the
generated visitor automatically inherits from the appropriate class in
\oc|VisitorsRuntime|, so it receives default implementations of the methods
\tyconvisitor{int}, \tyconvisitor{list}, and so on. The visitor methods for
parameterized data types (\oc|array|, \oc|Lazy.t|, \oc|list|, \oc|option|,
\oc|ref|, \oc|result|) are polymorphic, so it is not a problem if both lists
of apples and lists of oranges need to be traversed.

Nevertheless, at a primitive type, it is advisable to carefully consider what
behavior is desired. On the one hand, perhaps the inherited method
\tyconvisitor{int} need not be invoked in the first place; this behavior can
be obtained by using \oc|(int[@opaque])| instead of \oc|int|. (See
\sref{sec:opaque} for details.) This is done, for instance, in
\fref{fig:expr15}, where one can check that no call to \tyconvisitor{int} is
generated. On the other hand, when one decides to use an inherited method, one
should make sure that one understands its behavior. The methods
\tyconvisitor{array} and \tyconvisitor{ref} in the class
\oc|VisitorsRuntime.map|, for instance, perform a copy of a mutable memory
block: one should be aware that such a copy is taking place. If this behavior
is undesirable, it can be overridden.

It is possible to inherit as many classes as one wishes, beyond those defined
in \oc|VisitorsRuntime|. This is done via the \ancestors parameter
(\sref{sec:ancestors}).

% ------------------------------------------------------------------------------
% ------------------------------------------------------------------------------

\section{Advanced examples}
\label{sec:advanced}

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr12}
\vspace{-\baselineskip}
\processed{expr12}
\caption{An open type of arithmetic expressions} % and a visitor for it
\label{fig:expr12}
\end{figure}

\begin{figure}[p]
\codefollowup{expr12}
\origfirstline{expr13}{3}
\caption{A closed type of arithmetic expressions}
\label{fig:expr13}
\end{figure}

\begin{figure}[p]
\codefollowup{expr12}
\origfirstline{expr08}{3}
\caption{A closed type of hash-consed arithmetic expressions}
\label{fig:expr08}
\end{figure}

\subsection{Visitors for open and closed data types}
\label{sec:advanced:openclosed}

The algebraic data types of arithmetic expressions shown in the previous
section (\sref{sec:intro}) are \emph{closed}. That is, the type \oc|expr|
is recursive: an expression of type \oc|expr| has subexpressions of type
\oc|expr|.

It is often desirable, for greater flexibility, to first define an \emph{open}
type of arithmetic expressions. Such a type, say \oc|oexpr|, is parameterized
over a type variable~\oc|'expr|. It is not recursive: an expression of type
\oc|'expr oexpr| has subexpressions of type \oc|'expr|. It is shown in
\fref{fig:expr12}. Naturally, we may request the generation of visitors for
the type \oc|oexpr|. In \fref{fig:expr12}, we generate a class of \map
visitors, which we name \oc|omap|. (This is an example of using an explicit
\name parameter.) As explained earlier (\sref{sec:intro:parameterized}),
because the type \oc|oexpr| is parameterized over the type variable
\oc|'expr|, the visitor class has a virtual method, \tyconvisitor{'expr}.

A closed (recursive) type of expressions, \oc|expr|, can then be defined in
terms of \oc|expr|. This is done in \fref{fig:expr13}. In type-theoretical
terms, one would like to define \oc|expr| as the fixed point of the functor
\oc|oexpr|.
% TEMPORARY citation; demander à Pierre-Évariste
That is, roughly speaking, one would like to define \oc|type expr = expr oexpr|.
This is not accepted by OCaml, though;%
%
\footnote{It would be accepted by OCaml with the command line switch
  \texttt{-rectypes}, which instructs the typechecker to tolerate
  equirecursive types. However, this is not a good idea, as it causes
  the typechecker to suddenly accept many meaningless programs and infer
  bizarre types for them.}
%
we work around this limitation by making \oc|expr| an algebraic data type
whose single data constructor is named~\oc|E|.%
%
\footnote{We mark this algebraic data type \oc|[@@unboxed]|, which (as of
  OCaml 4.04) guarantees that there is no runtime cost associated with the
  data constructor~\oc|E|. Although \oc|expr| and \oc|expr oexpr| are
  considered distinct types by the OCaml type-checker, they have the same
  runtime representation.}

Let us now construct a visitor class for the type \oc|expr|. It is easy to
do so, by hand, in a few lines of code.%
%
\footnote{We could request the generation of a visitor class via a
  \oc|[@@deriving]| annotation. However, the type \oc|oexpr| would then be
  viewed as nonlocal; therefore, in the generated code, the method
  \tyconvisitor{oexpr} would be applied to \oc|self#visit_expr|, a
  parameter which it does not expect.}
%
% Also, we would have to inherit from \oc|omap|, but that would cause us
% to inherit twice from \oc|VisitorsRuntime.map|, causing warnings.
%
We define a class \oc|map|, a subclass of \oc|omap|, and provide a concrete
implementation of the virtual method \tyconvisitor{'expr}. In the definition
of the type \oc|expr|, the type variable \oc|'expr| is instantiated with
\oc|expr|, so the method \tyconvisitor{'expr} expects an argument of type
\oc|expr| and must return a result of type \oc|expr|. We deconstruct the
argument using the pattern \oc|E e|. Therefore, the variable \oc|e| has type
\oc|expr oexpr| and is a suitable argument to the method \tyconvisitor{oexpr}.
After this call, we perform the same step in reverse: the result of the call
has type \oc|expr oexpr|, so we wrap it in an application of the data
constructor~\oc|E| and obtain a result of type \oc|expr|.

The visitor class \oc|map| can now be used to implement transformations of
arithmetic expressions, that is, functions of type \oc|expr -> expr|. As an
example, let us implement a transformation whose effect is to double every
integer constant in an arithmetic expression. This is done in
\fref{fig:expr13double}. As expected, it suffices to construct a visitor
object that inherits \oc|map| and overrides the method
\dataconvisitor{EConst}.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\codefollowupgeneral{Figures~\ref{fig:expr12} and \ref{fig:expr13}}
\origfirstline{expr13double}{4}
\caption{A transformation of ordinary arithmetic expressions}
\label{fig:expr13double}
\end{figure}

\begin{figure}[p]
\codefollowupgeneral{Figures~\ref{fig:expr12} and \ref{fig:expr08}}
\origfirstline{expr08double}{4}
\caption{A transformation of hash-consed arithmetic expressions}
\label{fig:expr08double}
\end{figure}

\begin{figure}[p]
\codefollowupgeneral{Figures~\ref{fig:expr12}, \ref{fig:expr13}, and~\ref{fig:expr08}}
\origfirstline{expr14}{6}
\caption{Conversions between ordinary and hash-consed arithmetic expressions}
\label{fig:expr14}
\end{figure}

\subsection{Visitors for hash-consed abstract syntax trees}
\label{sec:advanced:hashconsed}

On top of the open data type \oc|oexpr| of the previous section
(\sref{sec:advanced:openclosed}), one can define not just the closed data type
\oc|expr| of ordinary arithmetic expressions, but also other closed data types
of expressions where every node is annotated with information.

As an example, let us define a type \oc|hexpr| of hash-consed (that is,
maximally-shared) arithmetic expressions. We use Filliâtre and Conchon's
library~\cite{filliatre-conchon-06}, which can be found in \opam under the
name \hashcons.

The definition of the type \oc|hexpr| appears in \fref{fig:expr08}. It is
analogous to the definition of the type \oc|expr| (\fref{fig:expr13}), with an
added twist: instead of taking the fixed point of the functor \oc|_ oexpr|, we
take the fixed point of the functor \oc|_ oexpr hash_consed|. By looking up
the definition of the type \oc|hash_consed| in \hashconsRepoFile{hashcons.mli},
one finds that this means that every node in an arithmetic expression carries
certain information (namely a unique tag and a hash) that are used to enforce
maximal sharing.

Enforcing maximal sharing requires maintaining a mutable table where all
arithmetic expressions ever constructed are stored. (This is in fact a weak
hash table.) We initialize such a table by calling the function
\oc|Hashcons.create|. This table is then populated by the function \oc|h|, a smart
constructor.
% of type \oc|hexpr oexpr -> hexpr|.
This function takes a candidate expression of type \oc|hexpr oexpr| and
returns an expression of type \oc|hexpr|, which is either allocated anew
or found in the table (should an identical expression already exist).

We can now construct a visitor class for the type \oc|hexpr|. As in the previous
section (\sref{sec:advanced:openclosed}), we do so by hand in a few lines of code.
%
% Our reasons for writing this code by hand are the same as in the previous
% section. Furthermore, we note that the code of the visitor refers to the
% function~\oc|h|, thus depends on \oc|table|. The definition of \oc|table|
% itself must come after the definition of the type \oc|hexpr|, since the
% type of \oc|table| is \oc|hexpr oexpr Hashcons.t|. For this reason, we
% cannot use [@@deriving] to generate the visitor just after the type
% definition.
%
% That said, since the visitor depends on \oc|h| and not directly on \oc|table|,
% we could cut the dependency by going through the store. Create a reference to
% a function of type \oc|hexpr oexpr -> hexpr|. Initialize it with a dummy
% function. Generate the visitor. Then, create the table, define \oc|h| and
% update the reference. Ugh.
%
The overall structure of this code is the same as in \fref{fig:expr13}. The
only difference is that the method \tyconvisitor{'expr} must now traverse
two levels of type structure, corresponding to \oc|_ oexpr hash_consed|.
It deconstructs this structure by using the pattern \oc|H { node = e ; _ }|,%
%
\footnote{The \oc|node| field is part of the record type \oc|hash_consed|;
see \hashconsRepoFile{hashcons.mli}.}
%
and reconstructs it by applying the smart constructor~\oc|h|.

A function \oc|double| can be defined for hash-consed arithmetic expressions
in exactly the same manner as we defined \oc|double| for ordinary arithmetic
expressions: compare \fref{fig:expr13double} and \fref{fig:expr08double}.
%
% In fact, although we did not attempt to share the code of the method
% \dataconvisitor{EConst} between these two figures, one could do so if
% desired, by exploiting multiple inheritance.
%

The visitor class \oc|omap| for open arithmetic expressions
(\fref{fig:expr12}) can be exploited to define conversions
between different types of arithmetic expressions.
This is illustrated in \fref{fig:expr14}.
There, the function \oc|import| converts an ordinary expression
to a hash-consed expression, thereby imposing maximal sharing.
Conversely, the function \oc|export| converts a hash-consed
expression into an ordinary expression, thereby abandoning
all sharing (and possibly causing an exponential explosion).
The implementation of these functions is simple: it is just
a matter of overriding \tyconvisitor{'expr} so as to deconstruct
one kind of expression and reconstruct the other kind.

% ------------------------------------------------------------------------------

\section{To be completed}
% TEMPORARY

\label{sec:regularity}
% The regularity restriction.

\label{sec:ancestors}
% The \ancestors parameter.

\label{sec:opaque}
% The @opaque annotation.
(Note the parentheses, which are required.)

\label{sec:oo:self}
% documenter plus clairement le fait que toutes nos classes
%           sont paramétrées vis-à-vis du type de 'self,
%           et les classes héritées via [ancestors] doivent suivre cette
%           même convention.

% documenter le fait que le code engendré ne contient aucune déclaration
% de type de méthode (ni concrète, ni virtuelle); nous laissons OCaml les
% inférer, ce qui réduit notre effort, nous garantit d'obtenir le type le
% plus général possible. De plus, en présence d'héritage de parents inconnus
% (via \ancestors) il nous est impossible de construire par nous-mêmes les
% types de ces méthodes.

% ------------------------------------------------------------------------------

\bibliographystyle{plain}
\bibliography{english}

\end{document}

% TEMPORARY

document the speed overhead compared to a native recursive function

document how to see the preprocessed code

document how to see its inferred type
  explain why we do not work in .mli files
  we cannot predict the types of the generated methods,
    because it depends on the types of the ancestor classes
  the generator is type-agnostic
    and although that may deemed disappointing,
    it is also the key reason why it is so simple and versatile
  show inferred types in the manual?
    tricky: many private methods
            a redundant constraint

document that non-regular ADTs are not supported
  existential types, GADTs not supported either
  that would require polymorphic methods

document @opaque
  careful with map2: an arbitrary choice takes place

list which types forms are unsupported
document how to deal with unsupported types
  wrap them in @opaque
  or replace them with type variables
  note the user can define their own opaque-like parameterized types
    and actually perform nontrivial treatment of the data of unsupported type
  could do HOAS as an example!
also unsupported: existential types, GADTs

document the OCaml object tricks that are used
  1. normally, unbound variables in method types are disallowed;
     one must make them parameters of the class (see OCaml manual)
     here, every class is parameterized over ['self]
     which allows all method types to be inferred (including virtual methods)
  2. methods are monomorphic, but class can be polymorphic
  3. can inherit classes that provide polymorphic methods
     i.e., user can supply code both a priori (by providing ancestor classes)
           and a posteriori (by defining child classes after the fact)
  4. can hide private methods in the signature
  -- anything else?
  -- the lazy-initializer trick, if used

référence:
  document the regularity restriction \label{sec:regularity} and the option irregular
  document all options
  document the option concrete
  document public
  avoid shadowing the following names: VisitorsRuntime, Lazy, Pervasives
  document which builtin types are supported by VisitorsRuntime
  document which OCaml types can/cannot be traversed

related work, for OCaml:
  ppx_deriving (generates monolithic code) (fixed number of templates)
  ppx_deriving_morphism
  Hongbo Zhang has `deriving at a distance' in Fan
    https://github.com/bobzhang/fan
    http://zhanghongbo.me/fan/
    http://zhanghongbo.me/fan/_downloads/metaprogramming_for_ocaml.pdf
  alphaCaml

related work, for other programming languages:
  Bound (Edward Kmett)
  Unbound (Weirich)
  RedPerl
  Francisco Ferreira et Brigitte Pientka, ESOP 2017 (Babybel)

related work, for proof assistants:
  Steven Keuchel
  Autosubst (voir Kaiser et al., CPP 2017)
  voir Guillaume Allais (CPP 2017, Agda et Haskell) et Goguen & McKinna

crazy title ideas:
  Dr Boilerplate, or: how I learned to stop worrying and love bound names

limitations:
  generated methods monomorphic, hand-written methods polymorphic
  problematic if a generated visitor for a parameterized data type
  later needs to be multi-instantiated in another data type.
