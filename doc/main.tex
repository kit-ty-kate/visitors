\documentclass[onecolumn,11pt,nocopyrightspace]{sigplanconf}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[bookmarks=true,bookmarksopen=true,colorlinks=true,%
            linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\usepackage{listings}
\input{listings-ocaml}
\lstset{language=ocaml}
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage{xspace}
\input{macros}
% Style.
\renewcommand{\emph}[1]{\textbf{#1}}

% ------------------------------------------------------------------------------
% Headings.

\title{Visitors}

\begin{document}
\authorinfo{François Pottier}{Inria Paris}{francois.pottier@inria.fr}
\maketitle

% ------------------------------------------------------------------------------

% TEMPORARY
\clearpage
% \tableofcontents
% \clearpage

% ------------------------------------------------------------------------------

\section{Introduction}
\label{sec:intro}

\subsection{Setup}
\label{sec:intro:setup}

In order to install the \visitors package, an \opam user should issue the
following commands:
\begin{verbatim}
  opam update
  opam install visitors
\end{verbatim}
In order to use the \visitors package, an \ocamlbuild user should add the
following line in her project's \texttt{\_tags} file:
\begin{lstlisting}
  true: package(visitors.ppx), package(visitors.runtime)
\end{lstlisting}
Furthermore, a \merlin user should add the following lines in her project's
\texttt{.merlin} file:
\begin{lstlisting}
  PKG visitors.ppx
  PKG visitors.runtime
\end{lstlisting}

% ------------------------------------------------------------------------------

\begin{figure}[t]
In an OCaml source file, a type definition can be annotated with
\oc|[@@deriving visitors { ... }]|:
\orig{expr00}
This causes the following code to be (invisibly) generated:
\processed{expr00}
\caption{A visitor of the \iter variety}
\label{fig:expr00}
\end{figure}

\subsection{\iter visitors: definition}
\label{sec:intro:iter:def}

Suppose we wish to work with arithmetic expressions built out of integer
literals and binary additions. An algebraic data type \oc|expr| is shown in
the first part of \fref{fig:expr00}. By annotating this type definition with
\oc|[@@deriving visitors { ... }]|, we request the automated generation of
a visitor for expressions. The code for this visitor, which in normal use
remains invisible, is shown in the second part of \fref{fig:expr00}.

The annotation \oc|[@@deriving visitors { ... }]| must carry at least two
parameters. The parameter \name can be an arbitrary string; it is used as the
name of the generated class. The parameter \variety must be one of \iter,
\map, \itertwo, \maptwo. It indicates which variety of visitor must be
generated.

A visitor takes the form of an OCaml class, whose methods are named after the
types and data constructors that appear in the type definition. In
\fref{fig:expr00}, for instance, the method \tyconvisitor{expr} is named after
the type \oc|expr|, while the methods \dataconvisitor{EConst} and
\dataconvisitor{EAdd} are named after the data constructors \oc|EConst| and
\oc|EAdd|.

A visitor of the \iter variety traverses a data structure. It returns no
result: its methods have return type \unit. The default implementations of
these methods do nothing. In \fref{fig:expr00}, for instance, the method
\tyconvisitor{expr} inspects its argument \oc|this_expr| and recursively
invokes either \dataconvisitor{EConst} or \dataconvisitor{EAdd}, as
appropriate. The method \dataconvisitor{EConst} does nothing. (More precisely,
it calls the function \oc|VisitorsRuntime.Int.iter|, which itself does
nothing.) The method \dataconvisitor{EAdd} performs two recursive calls to
\tyconvisitor{expr}, which does nothing, so \dataconvisitor{EAdd} itself does
nothing.

Every method is parameterized with an environment \oc|env|, which is carried
down into every recursive call and is otherwise unused.
% The type of this environment is therefore a priori undetermined.

% ------------------------------------------------------------------------------

\begin{figure}[t]
\origfirstline{expr04}{3}
\caption{Counting the number of addition nodes in an expression}
\label{fig:expr04}
\end{figure}

\subsection{\iter visitors: usage}
\label{sec:intro:iter:usage}

Naturally, traversing a data structure without actually computing anything is
not a very sensible thing to do. Things become interesting when at least one
visitor method is overridden so as to obtain a nontrivial behavior. Suppose,
for instance, that we wish to count the number of addition nodes in an
expression. This can be done as shown in \fref{fig:expr04}. We create an
object~\oc|v| which is both a counter (that is, it has a mutable
field~\oc|count|) and a visitor, and we override its method
\dataconvisitor{EAdd} so that the counter is incremented every time this
method is invoked. There remains to run the visitor, by invoking its
\tyconvisitor{expr} method, and to return the final value of the counter. The
environment, in this example, is unused; we let it have type \unit.

This may seem a rather complicated way of counting the addition nodes in an
expression. Of course, one could give a direct recursive definition of the
function \oc|count|, in a few lines of code, without using a visitor at all.
The point of employing a visitor, as done in Figures~\ref{fig:expr00}
and~\ref{fig:expr04}, is that no changes to the code are required when the
type of expressions is extended with new cases.

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr01}
\vspace{-\baselineskip}
\processed{expr01}
\caption{A visitor of the \map variety}
\label{fig:expr01}
\end{figure}

\subsection{\map visitors}
\label{sec:intro:map}

A visitor of the \iter variety (\sref{sec:intro:iter:def}) returns no result.
Although, as illustrated previously (\sref{sec:intro:iter:usage}), it can use
private mutable state to accumulate information, there are applications for
which such a visitor is not suitable. One class of such applications is tree
transformations. For this purpose, one must use a visitor of another variety,
namely \map.

How to request the generation of a \map visitor is shown in the first part of
\fref{fig:expr01}. The generated code appears in the second part of
\fref{fig:expr01}. In comparison with the \iter visitor of \fref{fig:expr00},
the code is identical, except that, instead of returning \oc|()|, the method
\dataconvisitor{EConst} reconstructs an \oc|EConst| expression, and the method
\dataconvisitor{EAdd} reconstructs an \oc|EAdd| expression.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr02}
\vspace{-\baselineskip}
\processed{expr02}
\caption{A visitor of the \itertwo variety}
\label{fig:expr02}
\end{figure}

\begin{figure}[p]
\orig{expr03}
\vspace{-\baselineskip}
\processed{expr03}
\caption{A visitor of the \maptwo variety}
\label{fig:expr03}
\end{figure}

\subsection{Visitors of arity two}
\label{sec:intro:aritytwo}

The \iter and \map visitors shown so far traverse one tree at a time. There
are situations where one wishes to simultaneously traverse two trees, which
one expects have the same structure. For this purpose, one should use a
visitor of arity 2. These come in two varities, namely \itertwo
(\fref{fig:expr02}) and \maptwo (\fref{fig:expr03}).

In these visitors, the method \tyconvisitor{expr} expects an environment and
two expressions. The two expressions must have identical structure: indeed, if
the method \tyconvisitor{expr} finds that the two expressions exhibit
different tags at the root, say \oc|EConst| versus \oc|EAdd|, then it invokes
the method \tyconfail{expr}, which by default calls \oc|VisitorsRuntime.fail()|,
which throws the exception \oc|VisitorsRuntime.StructuralMismatch|.

\begin{figure}[t]
\origfirstline{expr05}{3}
\caption{Determining whether two expressions are syntactically equal}
\label{fig:expr05}
\end{figure}

An \itertwo visitor can be used, for instance, to easily determine whether two
expressions are syntactically equal (\fref{fig:expr05}). Naturally, for this
particular purpose, one could use OCaml's primitive equality operator \oc|=|,
or one could exploit \ppxderiving and annotate the type definition with
\oc|[@@deriving eq]|. Visitors offer greater flexibility: for instance, if our
arithmetic expressions contained variables, we could easily define an
operation that tests whether two expressions are equal up to a renaming of
variables.
% More generally, if expressions contained variables and binders, we could
% define an operation that tests whether two expressions are $\alpha$-equivalent.

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr06}
\caption{Visitors for a family of types}
\label{fig:expr06}
\end{figure}

\subsection{Visitors for a family of types}
\label{sec:intro:family}

Visitors can be generated not just for one type definition, but for a family
of type definitions. In \fref{fig:expr06}, we propose a definition of
arithmetic expressions that involves three algebraic data types, namely
\oc|unop|, \oc|binop|, and \oc|expr|. We request the generation of two
visitors, namely an \iter visitor and a \map visitor. This causes the
generation of just two classes, named \iter and \map, respectively. Each of
these classes has visitor methods for every type (namely \tyconvisitor{unop},
\tyconvisitor{binop}, \tyconvisitor{expr}) and for every data constructor
(namely \dataconvisitor{UnaryMinus}, \dataconvisitor{BinaryMinus}, and so on).

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr09}
\vspace{-\baselineskip}
\processed{expr09}
\caption{A visitor for a parameterized type of decorated expressions}
\label{fig:expr09}
\end{figure}

\begin{figure}[p]
\origfirstline{expr10}{3}
\caption{Working with different types of decorations}
\label{fig:expr10}
\end{figure}

\subsection{Visitors for parameterized types}
\label{sec:intro:parameterized}

Visitors can be generated for parameterized types, too. (Technically, we
impose a restriction to \emph{regular} types; see \S\ref{sec:regularity}.)
%
In \fref{fig:expr09}, for instance, we define a variant of arithmetic
expressions where every tree node is decorated with a value of type
\oc|'info|. We request the generation of a \map visitor, whose code is shown
in the second part of \fref{fig:expr09}. The generated code has exactly the
same structure as in the previous sections. The only new feature is that the
class \map is now virtual, as it has a virtual method, \tyconvisitor{'info}.

The methods are \emph{not} declared polymorphic in the type
variable~\oc|'info|, or in two type variables~\oc|'info1| and~\oc|'info2|, as
one might perhaps expect. In fact, they must not be declared polymorphic:
indeed, the user who implements \tyconvisitor{'info} in a subclass of \map may
wish to provide an implementation that expects and/or produces specific types
of information.

As a result, every visitor \emph{object} is monomorphic: its method
\tyconvisitor{'info} must have type \oc|info1 -> info2| for certain specific
types \oc|info1| and \oc|info2|. Fortunately, the visitor \emph{class} is
polymorphic: therefore, two distinct visitor objects can have distinct types.

The class \map is \emph{not} parameterized over the type variable~\oc|'info|,
or over two type variables~\oc|'info1| and~\oc|'info2|, as one might perhaps
expect. This is not necessary.%
\footnote{The class is parameterized over \oc|'self|, and that is sufficient.
  Indeed, the type \oc|'self| determines the type of all methods, including
  \tyconvisitor{'info}. Therefore, \oc|'self| determines \oc|'info|.}

\fref{fig:expr10} presents two example uses of the class \map. In the first
example, we define a function \oc|strip|, of type \oc|'info expr -> unit expr|,
which strips off the decorations in an arithmetic expression, replacing them
with unit values. In the second example, we define a function \oc|number|,
of type \oc|'info expr -> int expr|, which decorates each node in an arithmetic
expression with a unique integer number.%
\footnote{Because the \oc|info| field appears before the \oc|node| field in
  the definition of the type \oc|expr|, and because fields are visited
  left-to-right, we get a prefix numbering scheme. By exchanging these fields,
  we would get postfix numbering.}

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr11}
\vspace{-\baselineskip}
\processed{expr11}
\caption{Dealing with preexisting (parameterized) types, such as \oc|int| and \oc|list|}
\label{fig:expr11}
\end{figure}

\subsection{Dealing with preexisting types}
\label{sec:intro:nonlocal}

A type definition can contain references to the types that are being defined,
also known as \emph{local} types. For instance, in \fref{fig:expr00}, the
definition of \oc|EAdd| contains two references to a local type, namely
\oc|expr|.

A type definition can also contain references to pre-existing types, also
known as \emph{nonlocal} types. For instance, in \fref{fig:expr00}, the
definition of \oc|EConst| contains a reference to a nonlocal type, namely
\oc|int|, which happens to be one of OCaml's primitive types. In
\fref{fig:expr11}, the definition of \oc|EAdd| contains a reference to a
parameterized nonlocal type, namely \oc|list|, which happens to be defined in
OCaml's standard library.

The treatment of local types has been illustrated in the previous sections.
In short, for every local type, a visitor method is generated: for instance,
for the local type \oc|expr|, we generate the method \tyconvisitor{expr}.

The treatment of nonlocal types is different. We do not wish to adopt a scheme
where there is one visitor method per nonlocal type.%
%
\footnote{That would be too restrictive. For instance, imagine that a type
  definition contains references to both \oc|int list| and \oc|expr list|. If
  we relied on just one method \tyconvisitor{list}, then this method would be
  used at two different types. Because our methods are monomorphic, that would
  cause a type error. One might consider instead declaring a polymorphic
  method, or declaring multiple monomorphic methods, but neither of these
  approaches seems workable.}
%
Instead, we expect one (possibly polymorphic) visitor \emph{function} to exist
for each nonlocal type. By convention, when generating an \iter visitor, the
visitor function for the type \oc|int| must be named \oc|Int.iter|; the
visitor function for the type (parameterized) type \oc|list| must be named
\oc|List.iter|; and so on. If the type definition contains a reference to a
nonlocal user-defined type \oc|foo|, then the visitor function for this type
must be named \oc|Foo.iter|.

For every OCaml primitive type, the library module \oc|VisitorsRuntime|, which
is automatically opened in the generated code, supplies suitable visitor
functions. The module \oc|VisitorsRuntime| contains several submodules named
\oc|Int|, \oc|List|, and so on; each of them supplies four functions named
\iter, \map, \itertwo, \maptwo.

For a user-defined type \oc|foo|, it is up to the user to ensure that a module
named \oc|Foo| can be found and offers these four functions. The \nonlocal
option (\sref{sec:nonlocal}) lets the user control where the module \oc|Foo|
is found.

% ------------------------------------------------------------------------------

% TEMPORARY illustration: types ouverts, et comment les fermer

% ------------------------------------------------------------------------------

% TEMPORARY illustration: types ouverts, fermés avec hash-consing

% ------------------------------------------------------------------------------

\end{document}

% TEMPORARY

référence:
  document the option \nonlocal \label{sec:nonlocal}
  document the regularity restriction \label{sec:regularity} and the option irregular

indiquer comment voir le code engendré
      et comment voir son type

related work:
  ppx_deriving (generates monolithic code) (fixed number of templates)
  ppx_deriving_morphism
  Hongbo Zhang has `deriving at a distance' in Fan
    https://github.com/bobzhang/fan
    http://zhanghongbo.me/fan/
    http://zhanghongbo.me/fan/_downloads/metaprogramming_for_ocaml.pdf
