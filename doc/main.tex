\documentclass[11pt,a4paper,twoside]{article}
\usepackage[left=25mm,right=25mm,top=25mm,bottom=25mm,marginparwidth=50pt]{geometry}
\setlength\abovecaptionskip{0pt} % Reduce space above figure captions.
\usepackage{lmodern} % This gives us a bold monospace font.
\renewcommand{\rmdefault}{ptm} % Times.
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[bookmarks=true,bookmarksopen=true,colorlinks=true,%
            linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\usepackage{marginnote}
\usepackage{listings}
\input{listings-ocaml}
\lstset{language=ocaml}
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage{xspace}
\input{macros}
% Style.
\renewcommand{\emph}[1]{\textbf{#1}}
\input{version}

% ------------------------------------------------------------------------------
% Headings.

\title{Visitors\\\normalsize version \visitorsversion}
\date{}
\begin{document}
\author{François Pottier\\ Inria Paris\\ \email{francois.pottier@inria.fr}}
\maketitle

% ------------------------------------------------------------------------------

\clearpage
\tableofcontents
\clearpage

% ------------------------------------------------------------------------------

% TEMPORARY can we adjust the number of columns when creating .processed.ml files?
% TEMPORARY fix the extra space before "in" in pprintast

\section{Introduction}
\label{sec:intro}

\subsection{Setup}
\label{sec:intro:setup}

In order to install the \visitors package, an \opam user should issue the
following commands:
\begin{verbatim}
  opam update
  opam install visitors
\end{verbatim}
In order to use the \visitors package, an \ocamlbuild user should add the
following line in her project's \texttt{\_tags} file:
\begin{lstlisting}
  true: package(visitors.ppx), package(visitors.runtime)
\end{lstlisting}
Furthermore, a \merlin user should add the following lines in her project's
\texttt{.merlin} file:
\begin{lstlisting}
  PKG visitors.ppx
  PKG visitors.runtime
\end{lstlisting}

% ------------------------------------------------------------------------------

\begin{figure}[t]
% In an OCaml source file, a type definition can be annotated with
% \oc|[@@deriving visitors { ... }]|:
\orig{expr00}
% This causes the following code to be (invisibly) generated:
\vspace{-\baselineskip}
\processed{expr00}
\caption{A visitor of the \iter variety}
\label{fig:expr00}
\end{figure}

\subsection{\iter visitors: definition}
\label{sec:intro:iter:def}

Suppose we wish to work with arithmetic expressions built out of integer
literals and binary additions. An algebraic data type \oc|expr| is shown in
the first part of \fref{fig:expr00}. By annotating this type definition with
\oc|[@@deriving visitors { ... }]|, we request the automated generation of
a visitor for expressions. The code for this visitor, which in normal use
remains invisible, is shown in the second part of \fref{fig:expr00}.

The annotation \oc|[@@deriving visitors { ... }]| must carry at least two
parameters. The parameter \name can be an arbitrary string; it is used as the
name of the generated class. The parameter \variety must be one of \iter,
\map, \itertwo, \maptwo. It indicates which variety of visitor must be
generated.

A visitor takes the form of an OCaml class, whose methods are named after the
types and data constructors that appear in the type definition. In
\fref{fig:expr00}, for instance, the method \tyconvisitor{expr} is named after
the type \oc|expr|, while the methods \dataconvisitor{EConst} and
\dataconvisitor{EAdd} are named after the data constructors \oc|EConst| and
\oc|EAdd|.

A visitor of the \iter variety traverses a data structure. It returns no
result: its methods have return type \unit. The default implementations of
these methods do nothing. In \fref{fig:expr00}, for instance, the method
\tyconvisitor{expr} inspects its argument \oc|this_expr| and recursively
invokes either \dataconvisitor{EConst} or \dataconvisitor{EAdd}, as
appropriate. The method \dataconvisitor{EConst} does nothing. (More precisely,
it calls the function \oc|VisitorsRuntime.Int.iter|, which itself does
nothing.) The method \dataconvisitor{EAdd} performs two recursive calls to
\tyconvisitor{expr}, which does nothing, so \dataconvisitor{EAdd} itself does
nothing.

Every method is parameterized with an environment \oc|env|, which is carried
down into every recursive call and is otherwise unused.
% The type of this environment is therefore a priori undetermined.

% ------------------------------------------------------------------------------

\begin{figure}[t]
\codefollowup{expr00}
\origfirstline{expr04}{3}
\caption{Counting the number of addition nodes in an expression}
\label{fig:expr04}
\end{figure}

\subsection{\iter visitors: usage}
\label{sec:intro:iter:usage}

Naturally, traversing a data structure without actually computing anything is
not a very sensible thing to do. Things become interesting when at least one
visitor method is overridden so as to obtain a nontrivial behavior. Suppose,
for instance, that we wish to count the number of addition nodes in an
expression. This can be done as shown in \fref{fig:expr04}. We create an
object~\oc|v| which is both a counter (that is, it has a mutable
field~\oc|count|) and a visitor, and we override its method
\dataconvisitor{EAdd} so that the counter is incremented every time this
method is invoked. There remains to run the visitor, by invoking its
\tyconvisitor{expr} method, and to return the final value of the counter. The
environment, in this example, is unused; we let it have type \unit.

This may seem a rather complicated way of counting the addition nodes in an
expression. Of course, one could give a direct recursive definition of the
function \oc|count|, in a few lines of code, without using a visitor at all.
The point of employing a visitor, as done in Figures~\ref{fig:expr00}
and~\ref{fig:expr04}, is that no changes to the code are required when the
type of expressions is extended with new cases.

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr01}
\vspace{-\baselineskip}
\processed{expr01}
\caption{A visitor of the \map variety}
\label{fig:expr01}
\end{figure}

\subsection{\map visitors}
\label{sec:intro:map}

A visitor of the \iter variety (\sref{sec:intro:iter:def}) returns no result.
Although, as illustrated previously (\sref{sec:intro:iter:usage}), it can use
private mutable state to accumulate information, there are applications for
which such a visitor is not suitable. One class of such applications is tree
transformations. For this purpose, one must use a visitor of another variety,
namely \map.

How to request the generation of a \map visitor is shown in the first part of
\fref{fig:expr01}. The generated code appears in the second part of
\fref{fig:expr01}. In comparison with the \iter visitor of \fref{fig:expr00},
the code is identical, except that, instead of returning \oc|()|, the method
\dataconvisitor{EConst} reconstructs an \oc|EConst| expression, and the method
\dataconvisitor{EAdd} reconstructs an \oc|EAdd| expression.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr02}
\vspace{-\baselineskip}
\processed{expr02}
\caption{A visitor of the \itertwo variety}
\label{fig:expr02}
\end{figure}
% TEMPORARY note we have declared it concrete because we wish to
% instantiate this class in expr05

\begin{figure}[p]
\orig{expr03}
\vspace{-\baselineskip}
\processed{expr03}
\caption{A visitor of the \maptwo variety}
\label{fig:expr03}
\end{figure}

\subsection{Visitors of arity two}
\label{sec:intro:aritytwo}

The \iter and \map visitors shown so far traverse one tree at a time. There
are situations where one wishes to simultaneously traverse two trees, which
one expects have the same structure. For this purpose, one should use a
visitor of arity 2. These come in two varities, namely \itertwo
(\fref{fig:expr02}) and \maptwo (\fref{fig:expr03}).

In these visitors, the method \tyconvisitor{expr} expects an environment and
two expressions. These expressions must have identical structure: indeed, if
\tyconvisitor{expr} finds that they exhibit different tags at the root, say
\oc|EConst| versus \oc|EAdd|, then it invokes the method \tyconfail{expr},
which by default calls \oc|VisitorsRuntime.fail()|, which throws the exception
\oc|VisitorsRuntime.StructuralMismatch|.

\begin{figure}[t]
\codefollowup{expr02}
\origfirstline{expr05}{3}
\caption{Determining whether two expressions are syntactically equal}
\label{fig:expr05}
\end{figure}

An \itertwo visitor can be used, for instance, to easily determine whether two
expressions are syntactically equal (\fref{fig:expr05}). Naturally, for this
particular purpose, one could use OCaml's primitive equality operator \oc|=|.
Alternatively, one could exploit \ppxderiving and annotate the type definition with
\oc|[@@deriving eq]|. Visitors offer greater flexibility: for instance, if our
arithmetic expressions contained variables, we could easily define an
operation that tests whether two expressions are equal up to a renaming of
variables.
% More generally, if expressions contained variables and binders, we could
% define an operation that tests whether two expressions are $\alpha$-equivalent.

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr06}
\caption{Visitors for a family of types}
\label{fig:expr06}
\end{figure}

\subsection{Visitors for a family of types}
\label{sec:intro:family}

Visitors can be generated not just for one type definition, but for a family
of type definitions. In \fref{fig:expr06}, we propose a definition of
arithmetic expressions that involves three algebraic data types, namely
\oc|unop|, \oc|binop|, and \oc|expr|. We request the generation of two
visitors, namely an \iter visitor and a \map visitor. This causes the
generation of just two classes, named \iter and \map, respectively. Each of
these classes has visitor methods for every type (namely \tyconvisitor{unop},
\tyconvisitor{binop}, \tyconvisitor{expr}) and for every data constructor
(namely \dataconvisitor{UnaryMinus}, \dataconvisitor{BinaryMinus}, and so on).

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr09}
\vspace{-\baselineskip}
\processed{expr09}
\caption{A visitor for a parameterized type of decorated expressions}
\label{fig:expr09}
\end{figure}

\begin{figure}[p]
\codefollowup{expr09}
\origfirstline{expr10}{3}
\caption{Working with different types of decorations}
\label{fig:expr10}
\end{figure}

\subsection{Visitors for parameterized types}
\label{sec:intro:parameterized}

Visitors can be generated for parameterized types, too. (Technically, we
impose a restriction to \emph{regular} types; see \S\ref{sec:regularity}.)
%
In \fref{fig:expr09}, for instance, we define a variant of arithmetic
expressions where every tree node is decorated with a value of type
\oc|'info|. We request the generation of a \map visitor, whose code is shown
in the second part of \fref{fig:expr09}. The generated code has exactly the
same structure as in the previous sections. The only new feature is that the
class \map is now virtual, as it has a virtual method, \tyconvisitor{'info}.

The visitor methods are \emph{not} declared polymorphic in the type
variable~\oc|'info|, or in two type variables~\oc|'info1| and~\oc|'info2|, as
one might perhaps expect. In fact, they must not be declared polymorphic:
indeed, the user who implements \tyconvisitor{'info} in a subclass of \map may
wish to provide an implementation that expects and/or produces specific types
of information.

As a result, a visitor \emph{object} is monomorphic: its method
\tyconvisitor{'info} must have type \oc|info1 ->| \oc|info2| for certain specific
types \oc|info1| and \oc|info2|. Fortunately, the visitor \emph{class} is
polymorphic: therefore, two distinct visitor objects can have distinct types.
% TEMPORARY pointer le fait qu'on peut très bien hériter d'une classe qui
%           contient des méthodes polymorphes.

The class \map is \emph{not} parameterized over the type variable~\oc|'info|,
or over two type variables~\oc|'info1| and~\oc|'info2|, as one might perhaps
expect. This is not necessary.%
\footnote{The class is parameterized over \oc|'self|, and that is sufficient.
  Indeed, the type \oc|'self| determines the type of all methods, including
  \tyconvisitor{'info}. Therefore, \oc|'self| determines \oc|'info|.}
% TEMPORARY documenter plus clairement le fait que toutes nos classes
%           sont paramétrées vis-à-vis du type de 'self,
%           et les classes héritées via [ancestors] doivent suivre cette
%           même convention.

\fref{fig:expr10} presents two example uses of the class \map. In the first
example, we define a function \oc|strip|, of type \oc|'info expr -> unit expr|,
which strips off the decorations in an arithmetic expression, replacing them
with unit values. In the second example, we define a function \oc|number|,
of type \oc|'info expr -> int expr|, which decorates each node in an arithmetic
expression with a unique integer number.%
\footnote{Because the \oc|info| field appears before the \oc|node| field in
  the definition of the type \oc|expr|, and because fields are visited
  left-to-right, we get a prefix numbering scheme. By exchanging these fields,
  we would get postfix numbering.}

% ------------------------------------------------------------------------------

\begin{figure}[t]
\orig{expr11}
\vspace{-\baselineskip}
\processed{expr11}
\caption{Dealing with preexisting (parameterized) types, such as \oc|int| and \oc|list|}
\label{fig:expr11}
\end{figure}

\subsection{Dealing with preexisting types}
\label{sec:intro:nonlocal}

A type definition can contain references to the types that are being defined,
also known as \emph{local} types. For instance, in \fref{fig:expr00}, the
definition of \oc|EAdd| contains two references to a local type, namely
\oc|expr|.

A type definition can also contain references to pre-existing types, also
known as \emph{nonlocal} types. For instance, in \fref{fig:expr00}, the
definition of \oc|EConst| contains a reference to a nonlocal type, namely
\oc|int|, which happens to be one of OCaml's primitive types. In
\fref{fig:expr11}, the definition of \oc|EAdd| contains a reference to a
parameterized nonlocal type, namely \oc|list|, which happens to be defined in
OCaml's standard library.

The treatment of local types has been illustrated in the previous sections.
In short, for every local type, a visitor method is generated: for instance,
for the local type \oc|expr|, we generate the method \tyconvisitor{expr}.

The treatment of nonlocal types is the same, except instead of generating a
concrete method definition, we generate a virtual method declaration.

% TEMPORARY section à revoir
%    noter que le type de la méthode virtuelle n'est pas connu de nous,
%    mais est inféré par OCaml

% TEMPORARY illustrer le traitement des listes
% For instance, imagine that a type definition contains references to both
% \oc|int list| and \oc|expr list|. If we relied on just one method
% \tyconvisitor{list}, then this method would be used at two different types.

For every OCaml primitive type, the library module \oc|VisitorsRuntime|, which
is automatically opened in the generated code, supplies suitable visitor
classes. The module \oc|VisitorsRuntime| contains several classes named
\oc|iter|, \oc|map|, and so on; each of them supplies methods named
\tyconvisitor{int}, \tyconvisitor{list}, and so on. (Please consult
  \srcFile{VisitorsRuntime.mli} for details.) The generated visitor
automatically inherits from one of these classes, so it gets default
implementations of the methods \tyconvisitor{int}, \tyconvisitor{list},
and so on.

% ------------------------------------------------------------------------------
% ------------------------------------------------------------------------------

\section{Advanced examples}
% TEMPORARY ou: applications, illustrations?
%           ou: playing with open/closed data types, tying knots, hash-consing?
\label{sec:advanced}

% ------------------------------------------------------------------------------

\begin{figure}[p]
\orig{expr12}
\vspace{-\baselineskip}
\processed{expr12}
\caption{An open type of arithmetic expressions} % and a visitor for it
\label{fig:expr12}
\end{figure}
% TEMPORARY also an example of explicit [name]

\begin{figure}[p]
\codefollowup{expr12}
\origfirstline{expr13}{3}
\caption{A closed type of arithmetic expressions}
\label{fig:expr13}
\end{figure}

\begin{figure}[p]
\codefollowup{expr12}
\origfirstline{expr08}{3}
\caption{A closed type of hash-consed arithmetic expressions}
\label{fig:expr08}
\end{figure}

\subsection{Visitors for open and closed data types}
\label{sec:advanced:openclosed}

The algebraic data types of arithmetic expressions shown in the previous
section (\sref{sec:intro}) are \emph{closed}. That is, the type \oc|expr|
is recursive: an expression of type \oc|expr| has subexpressions of type
\oc|expr|.

It is often desirable, for greater flexibility, to first define an \emph{open}
type of arithmetic expressions. Such a type, say \oc|oexpr|, is parameterized
over a type variable~\oc|'expr|. It is nonrecursive: an expression of type
\oc|'expr oexpr| has subexpressions of type \oc|'expr|. It is shown in
\fref{fig:expr12}. Naturally, we may request the generation of visitors for
the type \oc|oexpr|. In \fref{fig:expr12}, we generate a class of \map
visitors, which we name \oc|omap|. As explained earlier
(\sref{sec:intro:parameterized}), this class has a virtual method,
\tyconvisitor{'expr}.

The closed (recursive) type of expressions, \oc|expr|, can then be defined in
terms of \oc|expr|. This is done in \fref{fig:expr13}. In type-theoretical
terms, one would like to define \oc|expr| as the fixed point of the functor
\oc|oexpr|.
% TEMPORARY citation; demander à Pierre-Évariste
That is, roughly speaking, one would like to define \oc|type expr = expr oexpr|.
This is not accepted by OCaml, though;%
%
\footnote{It would be accepted by OCaml with the command line switch
  \texttt{-rectypes}, which instructs the typechecker to tolerate
  equirecursive types. However, this is \emph{not} a good idea, as it causes
  the typechecker to suddenly accept many meaningless programs and infer
  bizarre types for them.}
%
we work around this limitation by making \oc|expr| an algebraic data type
whose single data constructor is named~\oc|E|.%
%
\footnote{We mark this algebraic data type \oc|[@@unboxed]|, which (as of
  OCaml 4.04) guarantees that there is no runtime cost associated with the
  data constructor~\oc|E|. A value of type \oc|expr| is represented at
  runtime as a value of type \oc|expr oexpr|.}

Let us now construct a visitor class for the type \oc|expr|. It is easy to
do so, by hand, in a few lines of code.%
%
\footnote{We could request the generation of a visitor class via a
  \oc|[@@deriving]| annotation. However, the type \oc|oexpr| would then be
  viewed as nonlocal; therefore, we would have to first define a visitor
  function \oc|Oexpr.map| for the type \oc|oexpr|. That could be done. More
  seriously, the generated visitor class would have only one method, namely
  \tyconvisitor{expr}, so it would not be customizable by inheritance, as it
  should be.}
%
We define a class \oc|map|, a subclass of \oc|omap|, and provide a concrete
implementation of the virtual method \tyconvisitor{'expr}. In the definition
of the type \oc|expr|, the type variable \oc|'expr| is instantiated with
\oc|expr|, so the method \tyconvisitor{'expr} expects an argument of type
\oc|expr| and must return a result of type \oc|expr|. We deconstruct the
argument using the pattern \oc|E e|. Therefore, the variable \oc|e| has type
\oc|expr oexpr| and is a suitable argument to the method \tyconvisitor{oexpr}.
After this call, we perform the same step in reverse: the result of the call
has type \oc|expr oexpr|, so we wrap it in an application of the data
constructor~\oc|E| and obtain a result of type \oc|expr|.

The visitor class \oc|map| can now be used to implement transformations of
arithmetic expressions, that is, functions of type \oc|expr -> expr|. As an
example, let us implement a transformation whose effect is to double every
integer constant in an arithmetic expression. This is done in
\fref{fig:expr13double}. As expected, it suffices to construct a visitor
object that inherits \oc|map| and overrides the method
\dataconvisitor{EConst}.

% ------------------------------------------------------------------------------

\begin{figure}[p]
\codefollowupgeneral{Figures~\ref{fig:expr12} and \ref{fig:expr13}}
\origfirstline{expr13double}{4}
\caption{A transformation of ordinary arithmetic expressions}
\label{fig:expr13double}
\end{figure}

\begin{figure}[p]
\codefollowupgeneral{Figures~\ref{fig:expr12} and \ref{fig:expr08}}
\origfirstline{expr08double}{4}
\caption{A transformation of hash-consed arithmetic expressions}
\label{fig:expr08double}
\end{figure}

\begin{figure}[p]
\codefollowupgeneral{Figures~\ref{fig:expr12}, \ref{fig:expr13}, and~\ref{fig:expr08}}
\origfirstline{expr14}{6}
\caption{Conversions between ordinary and hash-consed arithmetic expressions}
\label{fig:expr14}
\end{figure}

\subsection{Visitors for hash-consed abstract syntax trees}
\label{sec:advanced:hashconsed}

On top of the open data type \oc|oexpr| of the previous section
(\sref{sec:advanced:openclosed}), one can define not just the closed data type
\oc|expr| of ordinary arithmetic expressions, but also other closed data types
of expressions where every node is annotated with information.

As an example, let us define a type \oc|hexpr| of hash-consed (that is,
maximally-shared) arithmetic expressions. We use Filliâtre and Conchon's
library~\cite{filliatre-conchon-06}, which can be found in \opam under the
name \hashcons.

The definition of the type \oc|hexpr| appears in \fref{fig:expr08}. It is
analogous to the definition of the type \oc|expr| (\fref{fig:expr13}), with an
added twist: instead of taking the fixed point of the functor \oc|_ oexpr|, we
take the fixed point of the functor \oc|_ oexpr hash_consed|. By looking up
the definition of the type \oc|hash_consed| in \hashconsRepoFile{hashcons.mli},
one finds that this means that every node in an arithmetic expression carries
certain information (namely a unique tag and a hash) that are used to enforce
maximal sharing.

Enforcing maximal sharing requires maintaining a mutable table where all
arithmetic expressions ever constructed are stored. (This is in fact a weak
hash table.) We initialize such a table by calling the function
\oc|Hashcons.create|. This table is then populated by the function \oc|h|, a smart
constructor.
% of type \oc|hexpr oexpr -> hexpr|.
This function takes a candidate expression of type \oc|hexpr oexpr| and
returns an expression of type \oc|hexpr|, which is either allocated anew
or found in the table (should an identical expression already exist).

We can now construct a visitor class for the type \oc|hexpr|. As in the previous
section (\sref{sec:advanced:openclosed}), we do so by hand in a few lines of code.
%
% Our reasons for writing this code by hand are the same as in the previous
% section. Furthermore, we note that the code of the visitor refers to the
% function~\oc|h|, thus depends on \oc|table|. The definition of \oc|table|
% itself must come after the definition of the type \oc|hexpr|, since the
% type of \oc|table| is \oc|hexpr oexpr Hashcons.t|. For this reason, we
% cannot use [@@deriving] to generate the visitor just after the type
% definition.
%
% That said, since the visitor depends on \oc|h| and not directly on \oc|table|,
% we could cut the dependency by going through the store. Create a reference to
% a function of type \oc|hexpr oexpr -> hexpr|. Initialize it with a dummy
% function. Generate the visitor. Then, create the table, define \oc|h| and
% update the reference. Ugh.
%
The overall structure of this code is the same as in \fref{fig:expr13}. The
only difference is that the method \tyconvisitor{'expr} must now traverse
two levels of type structure, corresponding to \oc|_ oexpr hash_consed|.
It deconstructs this structure by using the pattern \oc|H { node = e ; _ }|,%
%
\footnote{The \oc|node| field is part of the record type \oc|hash_consed|;
see \hashconsRepoFile{hashcons.mli}.}
%
and reconstructs it by applying the smart constructor~\oc|h|.

A function \oc|double| can be defined for hash-consed arithmetic expressions
in exactly the same manner as we defined \oc|double| for ordinary arithmetic
expressions: compare \fref{fig:expr13double} and \fref{fig:expr08double}.
%
% In fact, although we did not attempt to share the code of the method
% \dataconvisitor{EConst} between these two figures, one could do so if
% desired, by exploiting multiple inheritance.
%

The visitor class \oc|omap| for open arithmetic expressions
(\fref{fig:expr12}) can be exploited to define conversions
between different types of arithmetic expressions.
This is illustrated in \fref{fig:expr14}.
There, the function \oc|import| converts an ordinary expression
to a hash-consed expression, thereby imposing maximal sharing.
Conversely, the function \oc|export| converts a hash-consed
expression into an ordinary expression, thereby abandoning
all sharing (therefore possibly causing an exponential explosion).
The implementation of these functions is simple: it is just
a matter of overriding \tyconvisitor{'expr} so as to deconstruct
one kind of expression and reconstruct the other kind.

% ------------------------------------------------------------------------------

\bibliographystyle{plain}
\bibliography{english}

\end{document}

% TEMPORARY

documenter reduce
  iter est en fait un cas particulier de reduce,
  avec monoïde unit, et opération restrict triviale
  On pourrait donc se contenter de donner reduce,
  mais engendrer iter directement (si on n'a besoin que de lui)
  sera probablement plus efficace, et un peu plus simple
  show expr15 as an example application; also illustrates [name] and [ancestors]

référence:
  document the regularity restriction \label{sec:regularity} and the option irregular
  document the option concrete
  document public

indiquer comment voir le code engendré
      et comment voir son type

related work:
  ppx_deriving (generates monolithic code) (fixed number of templates)
  ppx_deriving_morphism
  Hongbo Zhang has `deriving at a distance' in Fan
    https://github.com/bobzhang/fan
    http://zhanghongbo.me/fan/
    http://zhanghongbo.me/fan/_downloads/metaprogramming_for_ocaml.pdf

  alphaCaml
  Steven Keuchel
  Bound (Edward Kmett)
  Unbound (Weirich)
