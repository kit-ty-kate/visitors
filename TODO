------------------------------------------------------------------------------

TODO (REALLY)

Add a way of NOT inheriting [VisitorsRuntime].

Investigate a way of generating (most of) the code in VisitorsRuntime.
  This will require polymorphic type annotations.

Implement mapreduce(2) in VisitorsRuntime.

Ideally, a datacon method should be parameterized with visit_'a
  only if 'a appears in the type of some component.

Understand what [subst_type] should do about @opaque types.

Check for TEMPORARYs.

Document [polymorphic].
  Show expr_info_polymorphic.
  Show ['a seq] -- polymorphic recursion.
  Document that 's and 'env are reserved.
  Document that one can control whether the methods should be polymorphic in 'env.

Document [data].

------------------------------------------------------------------------------

TODO (PERHAPS)

Think about enabling [polymorphic] and [fold] together.
That would require letting the user specify the result type
  associated with each type constructor.

Implement and document endoreduce?
  Share code by using "Map endo" internally where endo : bool.

Could define nontrivial [fold] and [fold2] in VisitorsRuntime.

Once we have that, can we deal with GADTs?

Add an annotation to rename a visitor method. (Reuben Rowe.)

Ancestors should be not just class names,
  but class expressions (e.g. a class name applied to some arguments).
Then, one should also have the ability of parameterizing
  the generated visitor with value arguments.
This could be used to define visit_hash_consed once and for all,
  in a clean way, as a base class that could be inherited,
  taking the memoization table as an argument.

In [fold],
  the build_ methods could take not only the results of the recursive calls,
  but also their arguments (for added expressive power).

Develop a real test suite, with expected output.
  Check for left-to-right traversal order.
  Release the test suite, too?
  Some tests have dependencies on other packages: hashcons, core_bench...
  Run these tests only if these packages are installed, warn otherwise?

Add [opaque] as an option, carrying a list of types.
  That would be lighter than writing [@opaque] at every occurrence.

Include an option [except t] to omit the definition of visitor methods for the type [t].
  That would allow the user to provide their own implementation,
  (possibly inherited / polymorphic),
  without having to satisfy the type constraints imposed by our implementation.
  e.g. could generate a [map] visitor where one type (in a family) is rewritten to something completely different

Detect and reject existential types and GADTs.

Could define a fold visitor where the methods receive the names of the types,
data constructors, and record fields that are being visited. (As in
ppx_tools/genlifter.)

Avoid generating beta-redexes.
  (fun (x, y) -> ...) z should be let (x, y) = z in ...
  See [visit_types].

Re-introduce hoisting of closure allocations of the form [self#visit_foo]?
  If so, share them when they have several occurrences.

[variety] could be a list.
  But then, one would need to replace <variety> with variety in
    [ancestors] and in [name] (if present).
  Somewhat tricky, as we would need to produce not one settings
    record, but several of them.

Implement a way of deferring visitor generation.
  (inserting user code between the type definition and the visitor class)
  (or, more generally, generating a visitor for a pre-existing type)

Do something about ~path?
  It seems connected to nested modules.

Think about generating analyze_ methods
  which perform a bottom-up computation (at most once; memoized)
  based only on the type structure
  so as to allow a static analysis of the type structure,
  which could be exploited to optimize runtime traversals.
