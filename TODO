------------------------------------------------------------------------------

TODO (REALLY)

------------------------------------------------------------------------------

TODO (PERHAPS)

In fully [polymorphic] mode, perhaps one could allow [@@deriving visitors]
  to be used in an .mli file, producing class types.

In [polymorphic] mode, we could annotate every invocation
  of an external visitor method with its expected (polymorphic) type,
  so as to get better type error messages if this method does not have
  the expected type.

Ideally, a visitor method should be parameterized with visit_'a
  only if 'a appears in the type of some component.
It would be good if a type parameter ['a] could be declared never-visited,
  so the method or function [visit_'a] would be unneeded.
  Could be useful for phantom type parameters, GADTs, 'bn, etc.
  The problem is, when a nonlocal type constructor is applied,
  we cannot know which parameters are phantom.
  Unless we find a way of declaring that, too?

Think about enabling [polymorphic] and [fold] together.
That would require letting the user specify the result type
  associated with each type constructor.

Implement and document endoreduce?
  Share code by using "Map endo" internally where endo : bool.

Maybe [fold] and [fold2] in VisitorsRuntime should just be aliases
  for [map] and [map2]. The user can use [nude] if that it is not appropriate.

Once we have that, can we deal with GADTs?

Add an annotation to rename a visitor method. (Reuben Rowe.)

Ancestors should be not just class names,
  but class expressions (e.g. a class name applied to some arguments).
Then, one should also have the ability of parameterizing
  the generated visitor with value arguments.
This could be used to define visit_hash_consed once and for all,
  in a clean way, as a base class that could be inherited,
  taking the memoization table as an argument.
  See hexpr_polymorphic.ml.

In [fold],
  the build_ methods could take not only the results of the recursive calls,
  but also their arguments (for added expressive power).

Develop a real test suite, with expected output.
  Check for left-to-right traversal order.
  Release the test suite, too?
  Some tests have dependencies on other packages: hashcons, core_bench...
  Run these tests only if these packages are installed, warn otherwise?

Add [opaque] as an option, carrying a list of types.
  That would be lighter than writing [@opaque] at every occurrence.

Include an option [except t] to omit the definition of visitor methods for the type [t].
  That would allow the user to provide their own implementation,
  (possibly inherited / polymorphic),
  without having to satisfy the type constraints imposed by our implementation.
  e.g. could generate a [map] visitor where one type (in a family) is rewritten to something completely different

Detect and reject existential types and GADTs.

Could define a fold visitor where the methods receive the names of the types,
data constructors, and record fields that are being visited. (As in
ppx_tools/genlifter.)

Avoid generating beta-redexes.
  (fun (x, y) -> ...) z should be let (x, y) = z in ...
  See [visit_types].

Re-introduce hoisting of closure allocations of the form [self#visit_foo]?
  If so, share them when they have several occurrences.

[variety] could be a list.
  But then, one would need to replace <variety> with variety in
    [ancestors] and in [name] (if present).
  Somewhat tricky, as we would need to produce not one settings
    record, but several of them.

Implement a way of deferring visitor generation.
  (inserting user code between the type definition and the visitor class)
  (or, more generally, generating a visitor for a pre-existing type)

Do something about ~path?
  It seems connected to nested modules.

Think about generating analyze_ methods
  which perform a bottom-up computation (at most once; memoized)
  based only on the type structure
  so as to allow a static analysis of the type structure,
  which could be exploited to optimize runtime traversals.
