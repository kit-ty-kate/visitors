------------------------------------------------------------------------------

TODO (REALLY)

If [name] is omitted then [variety] could be a list.
  But then, might need to replace <variety> with variety in [ancestors].
    in [name], too, if present
  Also, this is somewhat tricky, as we would produce not one settings
    record, but several of them?

Develop a real test suite, with expected output.
  Check for left-to-right traversal order.

Benchmark.
  Compare the speed of visitor-based code w.r.t. a recursive function.

Test on the Frama-C AST.
  Instantiate visit_'term and visit_'locs and make sure we have working code.

Develop support for names and binders (demos/lambda).
  Can we make it a functor, i.e., independent of the structure of terms?
  Check that every module has an .mli file, except where that would be too heavy.

Try dealing with binding and hash-consing at the same time.

Try dealing with suspended substitutions.
  (As a distinct construct. Not necessarily at abstractions.)

Document everything.
  The name [VisitorsRuntime] must not be shadowed.

Show to FranÃ§ois Bobot and Virgile Prevosto.
Show to Andrei and Jean-Christophe.
Add a LICENSE.
Create an opam package. Dependency on 4.03. Note @@unboxed requires 4.04.
  Dependencies on other packages for tests: hashcons, core_bench...
  Run these tests only if these packages are installed, warn otherwise?
Announce.

------------------------------------------------------------------------------

TODO (PERHAPS)

Implement a way of deferring visitor generation.
  (inserting user code between the type definition and the visitor class)

Might wish to allow ancestors to be not just class names
  but class expressions (e.g. a class name applied to some values).

Generate a variant of "iter" with an explicit accumulator?
  Would allow getting rid of mutable variables in user code.

Generate a generic (bottom-up) "fold" class?
  Create virtual build_ methods for local types.
  Use external functions for nonlocal types.
  Do something about tuples. (Reconstruct them identically?)
  Analogous to ppx_tools/genlifter.
  Would allow the user to define subclasses, possibly in several steps. Could be useful.

Hoist the application of self#visit_list to self#visit_expr,
  so as to avoid allocating a closure when traversing a list.
  (Difficult. Would probably require the lazy-initializer trick.)

Avoid generating beta-redexes.
  (fun (x, y) -> ...) z should be let (x, y) = z in ...

Do something about ~path?
  It seems connected to nested modules.

Think about automatically transforming a closed recursive type definition into
an open one.
