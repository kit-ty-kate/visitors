------------------------------------------------------------------------------

TODO (REALLY)

Continue to clean up near [ascend].
  Inline some functions used only once? [ifeqphys], [ifbuild]
  Share (bind rs ss (visit_types tys subjects) (ascend#ascend))

beware of capture: code in @build can see some private variables

Document @build for sum types and record types.
  Careful not to mis-spell it.

Document hexpr_polymorphic.

Add a pointer to http://gallium.inria.fr/blog/from-visitors-to-iterators/

mapreduce can serve to collect locations

create a new opam package visitorshashcons?

------------------------------------------------------------------------------

TODO (PERHAPS)

If there is an error, then the warnings are never seen,
  because they are placed in the generated code.
  Can we fix this?
  e.g. type t = A of (int -> int)[@opaque]

In fully [polymorphic] mode, perhaps one could allow [@@deriving visitors]
  to be used in an .mli file, producing class types.

In [polymorphic] mode, we could annotate every invocation
  of an external visitor method with its expected (polymorphic) type,
  so as to get better type error messages if this method does not have
  the expected type.

Ideally, a visitor method should be parameterized with visit_'a
  only if 'a appears in the type of some component.
It would be good if a type parameter ['a] could be declared never-visited,
  so the method or function [visit_'a] would be unneeded.
  Could be useful for phantom type parameters, GADTs, 'bn, etc.
  The problem is, when a nonlocal type constructor is applied,
  we cannot know which parameters are phantom.
  Unless we find a way of declaring that, too?

Think about enabling [polymorphic] and [fold] together.
That would require letting the user specify the result type
  associated with each type constructor.

Implement and document endoreduce?
  Share code by using "Map endo" internally where endo : bool.

Maybe [fold] and [fold2] in VisitorsRuntime should just be aliases
  for [map] and [map2]. The user can use [nude] if that it is not appropriate.

Once we have that, can we deal with GADTs?

In [fold],
  the build_ methods could take not only the results of the recursive calls,
  but also their arguments (for added expressive power).

Develop a real test suite, with expected output.
  Check for left-to-right traversal order.
  Release the test suite, too?
  Some tests have dependencies on other packages: hashcons, core_bench...
  Run these tests only if these packages are installed, warn otherwise?

Add [opaque] as an option, carrying a list of types.
  That would be lighter than writing [@opaque] at every occurrence.

Include an option [except t] to omit the definition of visitor methods for the type [t].
  That would allow the user to provide their own implementation,
  (possibly inherited / polymorphic),
  without having to satisfy the type constraints imposed by our implementation.
  e.g. could generate a [map] visitor where one type (in a family) is rewritten to something completely different

Detect and reject existential types and GADTs.

Could define a fold visitor where the methods receive the names of the types,
data constructors, and record fields that are being visited. (As in
ppx_tools/genlifter.)

Avoid generating beta-redexes.
  (fun (x, y) -> ...) z should be let (x, y) = z in ...
  See [visit_types].

Re-introduce hoisting of closure allocations of the form [self#visit_foo]?
  If so, share them when they have several occurrences.

Do something about ~path?
  It seems connected to nested modules.

Think about generating analyze_ methods
  which perform a bottom-up computation (at most once; memoized)
  based only on the type structure
  so as to allow a static analysis of the type structure,
  which could be exploited to optimize runtime traversals.
