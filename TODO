------------------------------------------------------------------------------

TODO (REALLY)

Implement mapreduce in VisitorsRuntime.
Implement and document endoreduce.
  Sharing code with "Map endo" internally.

------------------------------------------------------------------------------

TODO (PERHAPS)

Could define nontrivial [fold] and [fold2] in VisitorsRuntime.

Revisit the treatment of type parameters and polymorphic visitor methods.
  (Following Reuben Rowe.)
  Allow marking a type parameter as "generalized",
  and in that case, generate type annotations, so
  that the visitor methods are polymorphic in that
  type parameter.
  Works for iter, map, etc., but not for fold.

Once we have that, can we deal with GADTs?

Add an annotation to rename a visitor method. (Reuben Rowe.)

Ancestors should be not just class names,
  but class expressions (e.g. a class name applied to some arguments).
Then, one should also have the ability of parameterizing
  the generated visitor with value arguments.
This could be used to define visit_hash_consed once and for all,
  in a clean way, as a base class that could be inherited,
  taking the memoization table as an argument.

If [iter] and [reduce] inherited from [fold],
  with implementations of the [build_] methods,
  then it would be possible to override one of these methods
  to obtain custom behavior.
  Unfortunately, in the case of [map], this seems impossible.

In [fold],
  the build_ methods could take not only the results of the recursive calls,
  but also their arguments (for added expressive power).

Develop a real test suite, with expected output.
  Check for left-to-right traversal order.
  Release the test suite, too?
  Some tests have dependencies on other packages: hashcons, core_bench...
  Run these tests only if these packages are installed, warn otherwise?

Add [opaque] as an option, carrying a list of types.
  That would be lighter than writing [@opaque] at every occurrence.

Include an option [except] to omit the definition of certain methods.
  That would allow the user to provide their own implementation,
  (possibly inherited / polymorphic),
  without having to satisfy the type constraints imposed by our implementation.

Detect and reject existential types and GADTs.

Could define a fold visitor where the methods receive the names of the types,
data constructors, and record fields that are being visited. (As in
ppx_tools/genlifter.)

Avoid generating beta-redexes.
  (fun (x, y) -> ...) z should be let (x, y) = z in ...
  See [visit_types].

Re-introduce hoisting of closure allocations of the form [self#visit_foo]?
  If so, share them when they have several occurrences.

[variety] could be a list.
  But then, one would need to replace <variety> with variety in
    [ancestors] and in [name] (if present).
  Somewhat tricky, as we would need to produce not one settings
    record, but several of them.

Implement a way of deferring visitor generation.
  (inserting user code between the type definition and the visitor class)
  (or, more generally, generating a visitor for a pre-existing type)

Do something about ~path?
  It seems connected to nested modules.
